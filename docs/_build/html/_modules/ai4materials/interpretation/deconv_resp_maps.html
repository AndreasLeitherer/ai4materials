

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ai4materials.interpretation.deconv_resp_maps &mdash; ai4materials v0.1.0</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="ai4materials v0.1.0" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/>
    <link href="../../../_static/nomad-analytics.css" rel="stylesheet" type="text/css">


  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> ai4materials
          

          
            
            <img src="../../../_static/ai_for_materials_logo.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.dataprocessing.html">Data preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.descriptors.html">Representing crystal structures: descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.wrappers.html">Creating and loading materials science datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.models.html">Regression and classification models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.interpretation.html">Neural network interpretation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.utils.html">Utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../history.html">History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ai4materials</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>ai4materials.interpretation.deconv_resp_maps</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ai4materials.interpretation.deconv_resp_maps</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding=utf-8</span>
<span class="c1"># Copyright 2016-2018 Angelo Ziletti</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Angelo Ziletti&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2018, Angelo Ziletti&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Angelo Ziletti&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;ziletti@fhi-berlin.mpg.de&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;23/09/18&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;KERAS_BACKEND&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;theano&quot;</span>
<span class="kn">import</span> <span class="nn">keras.backend</span> <span class="k">as</span> <span class="nn">K</span>
<span class="kn">from</span> <span class="nn">keras.optimizers</span> <span class="k">import</span> <span class="n">Adam</span>
<span class="kn">from</span> <span class="nn">keras.models</span> <span class="k">import</span> <span class="n">model_from_json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="c1"># Force matplotlib to not use any Xwindows backend.</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;Agg&#39;</span><span class="p">)</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;export DISPLAY=:0&quot;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">switch_backend</span><span class="p">(</span><span class="s1">&#39;agg&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">gridspec</span>
<span class="kn">from</span> <span class="nn">ai4materials.utils.utils_plotting</span> <span class="k">import</span> <span class="n">make_multiple_image_plot</span>
<span class="kn">from</span> <span class="nn">ai4materials.utils.utils_plotting</span> <span class="k">import</span> <span class="n">rgb_colormaps</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">amin</span><span class="p">,</span> <span class="n">amax</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="k">import</span> <span class="n">Image</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ai4materials&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="load_model"><a class="viewcode-back" href="../../../ai4materials.interpretation.deconv_resp_maps.html#ai4materials.interpretation.deconv_resp_maps.load_model">[docs]</a><span class="k">def</span> <span class="nf">load_model</span><span class="p">(</span><span class="n">model_arch_file</span><span class="p">,</span> <span class="n">model_weights_file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Load Keras model from .json and .h5 files</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">json_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">model_arch_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">loaded_model_json</span> <span class="o">=</span> <span class="n">json_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">json_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">model_from_json</span><span class="p">(</span><span class="n">loaded_model_json</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loading model weights.&quot;</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="n">model_weights_file</span><span class="p">)</span>
    <span class="n">adam</span> <span class="o">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">lr</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">beta_1</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">beta_2</span><span class="o">=</span><span class="mf">0.999</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="s1">&#39;categorical_crossentropy&#39;</span><span class="p">,</span>
                  <span class="n">optimizer</span><span class="o">=</span><span class="n">adam</span><span class="p">,</span>
                  <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">])</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Model summary below.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">model</span></div>


<div class="viewcode-block" id="plot_att_response_maps"><a class="viewcode-back" href="../../../ai4materials.interpretation.deconv_resp_maps.html#ai4materials.interpretation.deconv_resp_maps.plot_att_response_maps">[docs]</a><span class="k">def</span> <span class="nf">plot_att_response_maps</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">model_arch_file</span><span class="p">,</span> <span class="n">model_weights_file</span><span class="p">,</span>
                           <span class="n">figure_dir</span><span class="p">,</span> <span class="n">nb_conv_layers</span><span class="p">,</span> <span class="n">layer_nb</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                           <span class="n">nb_top_feat_maps</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">filename_maps</span><span class="o">=</span><span class="s2">&quot;attentive_response_maps&quot;</span><span class="p">,</span>
                           <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">hot</span><span class="p">,</span>
                           <span class="n">plot_all_filters</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">plot_filter_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_summary</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Plot attentive response maps given a Keras trained model and</span>
<span class="sd">    input images.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    data: ndarray, shape (n_images, dim1, dim2, channels)</span>
<span class="sd">        Array of input images that will be used to calculate the</span>
<span class="sd">        attentive response maps.</span>

<span class="sd">    model_arch_file: string</span>
<span class="sd">        Full path to the model architecture file (.json format) written</span>
<span class="sd">        by Keras after the neural network training.</span>
<span class="sd">        This is used by the load_model function to load the neural network</span>
<span class="sd">        architecture.</span>

<span class="sd">    model_weights_file: string</span>
<span class="sd">        Full path to the model weights file (.h5 format) written by Keras</span>
<span class="sd">        after the neural network training .</span>
<span class="sd">        This is used by the load_model function to load the neural network</span>
<span class="sd">        architecture.</span>

<span class="sd">    figure_dir: string</span>
<span class="sd">        Full path of the directory where the images resulting from the</span>
<span class="sd">        transposed convolution procedure will be saved.</span>

<span class="sd">    nb_conv_layers: int</span>
<span class="sd">        Numbers of Convolution2D layers in the neural network architecture.</span>

<span class="sd">    layer_nb: list of int, or &#39;all&#39;</span>
<span class="sd">        List with the layer number which will be deconvolved starting from 0.</span>
<span class="sd">        E.g. layer_nb=[0, 1, 4] will deconvolve the 1st, 2nd, and 5th</span>
<span class="sd">        convolution2d layer. Only up to 6 conv_2d layers are supported.</span>
<span class="sd">        If &#39;all&#39; is selected, all conv_2d layers will be deconvolved,</span>
<span class="sd">        up to nb_conv_layers.</span>

<span class="sd">    nb_top_feat_maps: int</span>
<span class="sd">        Number of the top attentive response maps to be calculated and</span>
<span class="sd">        plotted. It must be &lt;= to the minimum number of filters used in the</span>
<span class="sd">        neural network layers. This is not checked by the code, and</span>
<span class="sd">        respecting this criterion is up to the user.</span>

<span class="sd">    filename_maps: str</span>
<span class="sd">        Base filename (without extension and path) of the files where the</span>
<span class="sd">        attentive response maps will be saved.</span>

<span class="sd">    cmap: Matplotlib cmap, optional, default=`cm.hot`</span>
<span class="sd">        Type of coloring for the heatmap, if images are greyscale.</span>
<span class="sd">        Possible cmaps can be found here:</span>
<span class="sd">        https://matplotlib.org/examples/color/colormaps_reference.html</span>
<span class="sd">        If images are RGB, then an RGB color map is used.</span>
<span class="sd">        The RGB colormap can be found at :py:mod:`ai4materials.utils.utils_plotting.rgb_colormaps`.</span>

<span class="sd">    plot_all_filters: bool</span>
<span class="sd">        If True, plot and save the nb_top_feat_maps for each layer.</span>
<span class="sd">        The files will be saved in different folders according to the layer:</span>
<span class="sd">        - &quot;convolution2d_1&quot; for the 1st layer</span>
<span class="sd">        - &quot;convolution2d_2&quot; for the 2nd layer</span>
<span class="sd">        etc.</span>

<span class="sd">    plot_filter_sum: bool</span>
<span class="sd">        If True, plot and save the sum of all the filters for a given layer.</span>

<span class="sd">    plot_summary: bool</span>
<span class="sd">        If True, plot and save a summary figure containing:</span>
<span class="sd">        (left) input image</span>
<span class="sd">        (center) nb_top_feat_maps filters for each deconvolved layer</span>
<span class="sd">        (right) sum of the all filters of the last layer</span>
<span class="sd">        If set to True, also plot_filter_sum must be set to True.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">load_model</span><span class="p">(</span><span class="n">model_arch_file</span><span class="p">,</span> <span class="n">model_weights_file</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">figure_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">figure_dir</span><span class="p">)</span>

    <span class="n">nb_input_imgs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># img_size = (#px #py #channels)</span>
    <span class="n">img_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">all_target_layers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx_conv_layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_conv_layers</span><span class="p">):</span>
        <span class="n">all_target_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;convolution2d_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_conv_layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># plot the attentive response maps for all images in the dataset</span>
    <span class="k">for</span> <span class="n">idx_img</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_input_imgs</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating attentive response map for figure </span><span class="si">{0}</span><span class="s2">/</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx_img</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nb_input_imgs</span><span class="p">))</span>
        <span class="c1"># plot input picture</span>
        <span class="n">input_picture</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx_img</span><span class="p">]</span>
        <span class="n">input_picture</span> <span class="o">=</span> <span class="n">input_picture</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="c1"># plt.imshow(input_picture, cmap=&#39;gray&#39;)</span>

        <span class="c1"># save input picture</span>
        <span class="n">filename_input</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_img</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_img_input.png&quot;</span>
        <span class="n">filename_input_full</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">figure_dir</span><span class="p">,</span> <span class="n">filename_input</span><span class="p">)))</span>
        <span class="c1"># to avoid whitespaces when saving</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">NullLocator</span><span class="p">())</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">NullLocator</span><span class="p">())</span>
        <span class="c1"># plt.savefig(filename_input_full, dpi=100, bbox_inches=&#39;tight&#39;, pad_inches=0.0, format=&#39;png&#39;)</span>

        <span class="c1"># save as proper picture</span>
        <span class="n">rgb_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">rgb_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_picture</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">255</span>
            <span class="n">rgb_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_picture</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">255</span>
            <span class="n">rgb_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_picture</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">255</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">img_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_picture</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">input_picture</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">input_picture</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">img_array</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unexpected number of color channels: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="n">img</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename_input_full</span><span class="p">)</span>

        <span class="c1"># get one image at a time to deconvolve</span>
        <span class="n">input_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx_img</span><span class="p">]</span>
        <span class="n">input_data</span> <span class="o">=</span> <span class="n">input_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">nb_channels</span> <span class="o">=</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># define colormaps</span>
        <span class="n">cmaps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">nb_channels</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># from 0 to full red, green and blue</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
                <span class="n">cmaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rgb_colormaps</span><span class="p">(</span><span class="n">color</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">nb_channels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cmaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unexpected number of color channels: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">layer_nb</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">target_layers</span> <span class="o">=</span> <span class="n">all_target_layers</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_layers</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_target_layers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">layer_nb</span><span class="p">)]</span>

        <span class="n">output_layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">target_layer</span> <span class="ow">in</span> <span class="n">target_layers</span><span class="p">:</span>
            <span class="c1"># output.shape = #img, #filters, #channels, #px, #py</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Processing layer: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_layer</span><span class="p">))</span>
            <span class="c1"># here the filters are calculated by transposed convolution</span>
            <span class="n">output</span><span class="p">,</span> <span class="n">feat_maps</span> <span class="o">=</span> <span class="n">deconv_visualize</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">nb_top_feat_maps</span><span class="p">)</span>
            <span class="n">output_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="n">output_layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">output_layers</span><span class="p">)</span>
        <span class="c1"># output_for_maps.shape = #img x #filters, #channels, #px, #py</span>
        <span class="n">output_for_maps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">output_layers</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">filename_maps_i</span> <span class="o">=</span> <span class="n">filename_maps</span> <span class="o">+</span> <span class="s2">&quot;_img_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_img</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span>
        <span class="n">filename_maps_i_full</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">figure_dir</span><span class="p">,</span> <span class="n">filename_maps_i</span><span class="p">)))</span>
        <span class="c1"># plot images</span>
        <span class="n">filenames_ch</span> <span class="o">=</span> <span class="n">make_multiple_image_plot</span><span class="p">(</span><span class="n">output_for_maps</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Attentive response maps&quot;</span><span class="p">,</span>
                                                <span class="n">n_rows</span><span class="o">=</span><span class="n">nb_top_feat_maps</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">target_layers</span><span class="p">),</span>
                                                <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                                                <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename_maps_i_full</span><span class="p">)</span>

        <span class="c1"># processing one image at a time</span>
        <span class="c1"># output_for_filters.shape = #layers #filters #channels #px, #py</span>
        <span class="n">output_for_filters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">output_layers</span><span class="p">,</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_layers</span><span class="p">),</span>
             <span class="n">nb_top_feat_maps</span><span class="p">,</span>
             <span class="n">img_size</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
             <span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
             <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">plot_all_filters</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx_layer</span><span class="p">,</span> <span class="n">target_layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_layers</span><span class="p">):</span>
                <span class="c1"># make a dir for each target layer</span>
                <span class="n">layer_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">figure_dir</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">)))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">layer_dir</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">layer_dir</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">idx_filter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_top_feat_maps</span><span class="p">):</span>
                    <span class="n">filename_filter_rgb_list</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">idx_ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_channels</span><span class="p">):</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
                        <span class="n">data_filter</span> <span class="o">=</span> <span class="n">output_for_filters</span><span class="p">[</span><span class="n">idx_layer</span><span class="p">,</span> <span class="n">idx_filter</span><span class="p">,</span> <span class="n">idx_ch</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

                        <span class="c1"># show only positive filters</span>
                        <span class="n">vmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">amin</span><span class="p">(</span><span class="n">data_filter</span><span class="p">))</span>
                        <span class="n">vmax</span> <span class="o">=</span> <span class="n">amax</span><span class="p">(</span><span class="n">data_filter</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">data_filter</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="n">idx_ch</span><span class="p">],</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)</span>

                        <span class="c1"># to avoid whitespaces when saving</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">NullLocator</span><span class="p">())</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">NullLocator</span><span class="p">())</span>

                        <span class="n">filter_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">target_layer</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="s2">&quot;filter_nb&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_filter</span><span class="p">)</span> <span class="o">+</span> \
                            <span class="s2">&quot;_image_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_img</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_ch&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_ch</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span>
                        <span class="n">filename_filter</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">layer_dir</span><span class="p">,</span> <span class="n">filter_name</span><span class="p">)))</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename_filter</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span> <span class="n">pad_inches</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;png&#39;</span><span class="p">)</span>

                        <span class="c1"># append to calculate the overlayed rgb picture</span>
                        <span class="n">filename_filter_rgb_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename_filter</span><span class="p">)</span>

                    <span class="c1"># plot the rgb sum of all filters</span>
                    <span class="c1"># get dimensions of first image (assuming all images are the same size)</span>
                    <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename_filter_rgb_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">size</span>

                    <span class="c1"># create a numpy array of floats to store the average (assume RGB images)</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                    <span class="c1"># build up average pixel intensities, casting each image as an array of floats</span>
                    <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">filename_filter_rgb_list</span><span class="p">:</span>
                        <span class="n">im_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">im_arr</span>

                    <span class="c1"># round values in array and cast as 8-bit integer</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                    <span class="c1"># generate, save and preview final image</span>
                    <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;RGBA&quot;</span><span class="p">)</span>

                    <span class="c1"># save filter sum</span>
                    <span class="n">filter_rgb_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">target_layer</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="s2">&quot;filter_nb&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_filter</span><span class="p">)</span> <span class="o">+</span> \
                        <span class="s2">&quot;_image_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_img</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_all_ch&quot;</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span>
                    <span class="n">filename_filter_rgb</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">layer_dir</span><span class="p">,</span> <span class="n">filter_rgb_name</span><span class="p">)))</span>
                    <span class="n">img</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename_filter_rgb</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_filter_sum</span><span class="p">:</span>
            <span class="n">filename_filter_sum_rgb_layers</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx_layer</span><span class="p">,</span> <span class="n">target_layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_layers</span><span class="p">):</span>
                <span class="n">filename_filter_sum_rgb_list</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># make a dir for each target layer</span>
                <span class="n">layer_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">figure_dir</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">)))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">layer_dir</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">layer_dir</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">idx_ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_channels</span><span class="p">):</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>

                    <span class="c1"># data_filter = output_for_filters[idx_layer, :, :, :, :]</span>
                    <span class="n">data_filter_ch</span> <span class="o">=</span> <span class="n">output_for_filters</span><span class="p">[</span><span class="n">idx_layer</span><span class="p">,</span> <span class="p">:,</span> <span class="n">idx_ch</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

                    <span class="c1"># sum up contributions from all filters to have the whole range of</span>
                    <span class="c1"># possibilities</span>
                    <span class="c1"># data_filter_ch is #filters, px, py</span>
                    <span class="n">combined_filters</span> <span class="o">=</span> <span class="n">data_filter_ch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">combined_filters</span> <span class="o">=</span> <span class="n">combined_filters</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

                    <span class="c1"># plt.imshow(input_picture, cmap=&#39;gray&#39;, vmin=0, vmax=0.05)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">combined_filters</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="n">idx_ch</span><span class="p">])</span>
                    <span class="c1"># show only positive filter</span>
                    <span class="n">vmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">amin</span><span class="p">(</span><span class="n">combined_filters</span><span class="p">))</span>
                    <span class="n">vmax</span> <span class="o">=</span> <span class="n">amax</span><span class="p">(</span><span class="n">combined_filters</span><span class="p">)</span>

                    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">combined_filters</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="n">idx_ch</span><span class="p">],</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)</span>

                    <span class="c1"># save filter sum</span>
                    <span class="n">filter_sum_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">target_layer</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_image_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_img</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_ch&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_ch</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_sum.png&quot;</span>
                    <span class="n">filename_filter_sum</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">layer_dir</span><span class="p">,</span> <span class="n">filter_sum_name</span><span class="p">)))</span>
                    <span class="c1"># to avoid whitespaces when saving</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">NullLocator</span><span class="p">())</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">NullLocator</span><span class="p">())</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename_filter_sum</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span> <span class="n">pad_inches</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;png&#39;</span><span class="p">)</span>

                    <span class="c1"># append to calculate the overlayed rgb picture</span>
                    <span class="n">filename_filter_sum_rgb_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename_filter_sum</span><span class="p">)</span>

                <span class="c1"># plot the rgb sum of all filters</span>
                <span class="c1"># Assuming all images are the same size, get dimensions of first image</span>
                <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename_filter_sum_rgb_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">size</span>

                <span class="c1"># Create a numpy array of floats to store the average (assume RGB images)</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="c1"># Build up average pixel intensities, casting each image as an array of floats</span>
                <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">filename_filter_sum_rgb_list</span><span class="p">:</span>
                    <span class="n">im_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">im_arr</span>

                <span class="c1"># Round values in array and cast as 8-bit integer</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="c1"># Generate, save and preview final image</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;RGBA&quot;</span><span class="p">)</span>

                <span class="c1"># save filter sum</span>
                <span class="n">filter_sum_rgb_name</span> <span class="o">=</span> <span class="s2">&quot;all_ch_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">target_layer</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_image_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_img</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_sum.png&quot;</span>
                <span class="n">filename_filter_sum_rgb</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">layer_dir</span><span class="p">,</span> <span class="n">filter_sum_rgb_name</span><span class="p">)))</span>
                <span class="n">img</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename_filter_sum_rgb</span><span class="p">)</span>

            <span class="c1"># list of the rgb sum of filters for all layers</span>
            <span class="n">filename_filter_sum_rgb_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename_filter_sum_rgb</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_summary</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">plot_filter_sum</span><span class="p">:</span>
                <span class="c1"># for each channel plot summary</span>
                <span class="k">for</span> <span class="n">idx_ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_channels</span><span class="p">):</span>
                    <span class="n">filename_summary</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_img</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_summary_plot_ch&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_ch</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span>
                    <span class="n">filename_summary_full</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">figure_dir</span><span class="p">,</span> <span class="n">filename_summary</span><span class="p">)))</span>

                    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
                    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;fivethirtyeight&#39;</span><span class="p">)</span>
                    <span class="n">input_img</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">filename_input_full</span><span class="p">)</span>
                    <span class="n">att_resp_maps</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">filenames_ch</span><span class="p">[</span><span class="n">idx_ch</span><span class="p">])</span>
                    <span class="c1"># plot sum of filters from last layer</span>
                    <span class="n">last_layer_filter_sum</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">filename_filter_sum_rgb</span><span class="p">)</span>

                    <span class="n">gs</span> <span class="o">=</span> <span class="n">gridspec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">width_ratios</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">gs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mf">0.90</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

                    <span class="n">ax0</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">ax0</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">input_img</span><span class="p">)</span>
                    <span class="n">ax0</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

                    <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">att_resp_maps</span><span class="p">)</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

                    <span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">last_layer_filter_sum</span><span class="p">)</span>
                    <span class="n">ax2</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

                    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename_summary_full</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;png&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot produce plot summary without filter sum. Set plot_filter_sum=True.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="deconv_visualize"><a class="viewcode-back" href="../../../ai4materials.interpretation.deconv_resp_maps.html#ai4materials.interpretation.deconv_resp_maps.deconv_visualize">[docs]</a><span class="k">def</span> <span class="nf">deconv_visualize</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">nb_top_feat_maps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Obtain attentive response maps back-projected to image space using transposed convolutions</span>
<span class="sd">    (sometimes referred as deconvolutions in machine learning).</span>

<span class="sd">    Parameters:</span>

<span class="sd">    model: instance of the Keras model</span>
<span class="sd">        The ConvNet model to be used.</span>

<span class="sd">    target_layer: str</span>
<span class="sd">        Name of the layer for which we want to obtain the attentive response maps. The names of the layers are defined</span>
<span class="sd">        in the Keras instance ``model``.</span>

<span class="sd">    input_data: ndarray</span>
<span class="sd">        The image data to be passed through the network. Shape: (n_samples, n_channels, img_dim1, img_dim2)</span>

<span class="sd">    nb_top_feat_maps: int</span>
<span class="sd">        Top-n filter you want to visualize, e.g. nb_top_feat_maps = 25 will visualize top 25 filters in target layer</span>

<span class="sd">    .. codeauthor:: Devinder Kumar &lt;d22kumar@uwaterloo.ca&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">feat_maps</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">Dec</span> <span class="o">=</span> <span class="n">DeconvNet</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

    <span class="n">deconv_imgs_batch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span>
        <span class="p">(</span><span class="n">input_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
         <span class="n">nb_top_feat_maps</span><span class="p">,</span>
         <span class="n">input_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
         <span class="n">input_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
         <span class="n">input_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Size of deconv batch init: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">deconv_imgs_batch</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using top </span><span class="si">{}</span><span class="s1"> filters&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nb_top_feat_maps</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">img_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">input_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">feat_maps</span> <span class="o">=</span> <span class="n">get_max_activated_filter_for_layer</span><span class="p">(</span><span class="n">target_layer</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">nb_top_feat_maps</span><span class="p">,</span> <span class="n">img_index</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;input data shape : </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">input_data</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">deconv_imgs</span> <span class="o">=</span> <span class="n">get_deconv_imgs</span><span class="p">(</span><span class="n">img_index</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">Dec</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">,</span> <span class="n">feat_maps</span><span class="p">)</span>
        <span class="n">deconv_imgs_batch</span><span class="p">[</span><span class="n">img_index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">deconv_imgs</span>

    <span class="k">return</span> <span class="n">deconv_imgs_batch</span><span class="p">,</span> <span class="n">feat_maps</span></div>


<div class="viewcode-block" id="get_max_activated_filter_for_layer"><a class="viewcode-back" href="../../../ai4materials.interpretation.deconv_resp_maps.html#ai4materials.interpretation.deconv_resp_maps.get_max_activated_filter_for_layer">[docs]</a><span class="k">def</span> <span class="nf">get_max_activated_filter_for_layer</span><span class="p">(</span><span class="n">target_layer</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">nb_top_feat_maps</span><span class="p">,</span> <span class="n">img_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the indices of the most activated filters for a given image in the specified target layer of a Keras model.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    target_layer: str</span>
<span class="sd">        Name of the layer for which we want to obtain the attentive response maps. The names of the layers are defined in the Keras instance ``model``.</span>

<span class="sd">    model: instance of the Keras model</span>
<span class="sd">        The ConvNet model to be used.</span>

<span class="sd">    input_data:</span>
<span class="sd">        input_data: ndarray</span>
<span class="sd">        The image data to be passed through the network. Shape: (n_samples, n_channels, img_dim1, img_dim2)</span>

<span class="sd">    nb_top_feat_maps:</span>
<span class="sd">        Number of the top attentive response maps to be calculated and plotted.</span>
<span class="sd">        It must be &lt;= to the minimum number of filters used in the  neural network layers. This is not checked by the code, and</span>
<span class="sd">        respecting this criterion is up to the user.</span>

<span class="sd">    img_index: list or ndarray</span>
<span class="sd">        Array or list of index. These are the indices of the images (contained in ``data``) for which we want to obtain the attentive response maps.</span>

<span class="sd">    Returns: list of int</span>
<span class="sd">        List containing the indices of the filters with the highest response (activation) for the given image.</span>

<span class="sd">    .. codeauthor:: Devinder Kumar &lt;d22kumar@uwaterloo.ca&gt;</span>
<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">input_data</span><span class="p">[</span><span class="n">img_index</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">layer_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">layer</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">layer</span><span class="p">)</span> <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">])</span>
    <span class="c1"># get the output of the target layer</span>
    <span class="c1"># see for example https://stackoverflow.com/questions/41711190/keras-how-to-get-the-output-of-each-layer</span>
    <span class="n">layer_output</span> <span class="o">=</span> <span class="n">layer_dict</span><span class="p">[</span><span class="n">target_layer</span><span class="p">]</span><span class="o">.</span><span class="n">output</span>

    <span class="c1"># keras.backend.function(inputs, outputs)</span>
    <span class="c1"># the Keras backend function is first created with placeholders and then the actual valued are passed</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">([</span><span class="n">model</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">()],</span> <span class="p">[</span><span class="n">layer_output</span><span class="p">])</span>
    <span class="n">output_response</span> <span class="o">=</span> <span class="n">response</span><span class="p">([</span><span class="n">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">filtered_images</span> <span class="o">=</span> <span class="p">((</span><span class="n">output_response</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># find the filtered images with the highest activation</span>
    <span class="n">sort_filter</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">filtered_images</span><span class="p">:</span>
        <span class="n">im_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="n">sort_filter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im_sum</span><span class="p">)</span>

    <span class="n">index_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sort_filter</span><span class="p">)</span>
    <span class="c1"># reversing the sorted list</span>
    <span class="n">index_sort</span> <span class="o">=</span> <span class="n">index_sort</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">top_n_filter</span> <span class="o">=</span> <span class="n">index_sort</span><span class="p">[:</span><span class="n">nb_top_feat_maps</span><span class="p">]</span>

    <span class="c1"># top_filtered_images = np.asarray([filtered_images.tolist()[i] for i in top_n_filter])</span>

    <span class="k">return</span> <span class="n">top_n_filter</span></div>


<div class="viewcode-block" id="get_deconv_imgs"><a class="viewcode-back" href="../../../ai4materials.interpretation.deconv_resp_maps.html#ai4materials.interpretation.deconv_resp_maps.get_deconv_imgs">[docs]</a><span class="k">def</span> <span class="nf">get_deconv_imgs</span><span class="p">(</span><span class="n">img_index</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dec_layer</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">,</span> <span class="n">feat_maps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the attentive response maps of the images specified in img_index for the target layer and feature maps</span>
<span class="sd">    specified in the arguments.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    img_index: list or ndarray</span>
<span class="sd">        Array or list of index. These are the indices of the images (contained in ``data``) for which we want to obtain the attentive response maps.</span>

<span class="sd">    data: ndarray</span>
<span class="sd">        The image data. Shape : (n_samples, n_channels, img_dim1, img_dim2)</span>

<span class="sd">    Dec: instance of class :py:mod:`ai4materials.interpretation.deconv_resp_maps.DeconvNet`</span>
<span class="sd">        DeconvNet model: instance of the DeconvNet class</span>

<span class="sd">    target_layer: str</span>
<span class="sd">        Name of the layer for which we want to obtain the attentive response maps. The names of the layers are defined in the Keras instance ``model``.</span>

<span class="sd">    feat_map: int</span>
<span class="sd">        Index of the attentive response map to visualise.</span>

<span class="sd">    .. codeauthor:: Devinder Kumar &lt;d22kumar@uwaterloo.ca&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">X_deconv</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">X_orig</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">img_index</span><span class="p">]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Shape of original images: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X_orig</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_orig</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">X_orig</span> <span class="o">=</span> <span class="n">X_orig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">X_orig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_orig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_orig</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">X_orig</span> <span class="o">=</span> <span class="n">X_orig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">X_orig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_orig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">X_orig</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">feat_map</span> <span class="ow">in</span> <span class="n">feat_maps</span><span class="p">:</span>
        <span class="n">X_deconv_img</span> <span class="o">=</span> <span class="n">dec_layer</span><span class="o">.</span><span class="n">get_deconv</span><span class="p">(</span><span class="n">X_orig</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">,</span> <span class="n">feat_map</span><span class="o">=</span><span class="n">feat_map</span><span class="p">)</span>
        <span class="c1"># from keras.layers import Deconv2D</span>
        <span class="c1"># X_deconv_img = Deconv2D(x, kernel, output_shape, strides=(1, 1), border_mode=&#39;valid&#39;,</span>
        <span class="c1">#          dim_ordering=&#39;default&#39;, image_shape=None, filter_shape=None)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Shape of images from transposed convolution: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X_deconv_img</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">X_deconv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_deconv_img</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">X_deconv_img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">X_deconv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X_deconv</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">X_deconv</span></div>


<div class="viewcode-block" id="DeconvNet"><a class="viewcode-back" href="../../../ai4materials.interpretation.deconv_resp_maps.html#ai4materials.interpretation.deconv_resp_maps.DeconvNet">[docs]</a><span class="k">class</span> <span class="nc">DeconvNet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;DeconvNet class. Code taken from:</span>
<span class="sd">    https://github.com/tdeboissiere/DeepLearningImplementations/blob/master/DeconvNet/KerasDeconv.py</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="n">list_layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">list_layers</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lnames</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lnames</span><span class="p">)),</span> <span class="s2">&quot;Non unique layer names&quot;</span>
        <span class="c1"># Dict of layers indexed by layer name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_layers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">l_name</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lnames</span><span class="p">,</span> <span class="n">list_layers</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">d_layers</span><span class="p">[</span><span class="n">l_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span>

        <span class="c1"># Tensor for function definitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tensor4</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_layers</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Erroneous layer name&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_deconv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lname</span><span class="p">,</span> <span class="n">d_switch</span><span class="p">,</span> <span class="n">feat_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">o_width</span><span class="p">,</span> <span class="n">o_height</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">lname</span><span class="p">]</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>

        <span class="c1"># Get filter size</span>
        <span class="n">f_width</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">lname</span><span class="p">]</span><span class="o">.</span><span class="n">W_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">f_height</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">lname</span><span class="p">]</span><span class="o">.</span><span class="n">W_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># Keras 2.0.</span>
        <span class="c1"># f_width = self[lname].kernel_size[0]</span>
        <span class="c1"># f_height = self[lname].kernel_size[1]</span>

        <span class="c1"># Compute padding needed</span>
        <span class="n">i_width</span><span class="p">,</span> <span class="n">i_height</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">pad_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">o_width</span> <span class="o">-</span> <span class="n">i_width</span> <span class="o">+</span> <span class="n">f_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">pad_height</span> <span class="o">=</span> <span class="p">(</span><span class="n">o_height</span> <span class="o">-</span> <span class="n">i_height</span> <span class="o">+</span> <span class="n">f_height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">pad_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pad_width</span><span class="p">)</span>
        <span class="n">pad_height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pad_height</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;Pad width size issue at layer </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">lname</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pad_height</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;Pad height size issue at layer </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">lname</span>

        <span class="c1"># Set to zero based on switch values</span>
        <span class="n">X</span><span class="p">[</span><span class="n">d_switch</span><span class="p">[</span><span class="n">lname</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Get activation function</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">lname</span><span class="p">]</span><span class="o">.</span><span class="n">activation</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">activation</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">feat_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting other feat map to zero&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">feat_map</span><span class="p">:</span>
                    <span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting non max activations to zero&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">iw</span><span class="p">,</span> <span class="n">ih</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">feat_map</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">argmax</span><span class="p">(),</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">feat_map</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">feat_map</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
                <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">feat_map</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">feat_map</span><span class="p">,</span> <span class="n">iw</span><span class="p">,</span> <span class="n">ih</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
        <span class="c1"># Get filters. No bias for now</span>
        <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">lname</span><span class="p">]</span><span class="o">.</span><span class="n">W</span>
        <span class="c1"># W = self[lname].kernel    # keras 2.0</span>

        <span class="c1"># Transpose filter</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># CUDNN for conv2d ?</span>
        <span class="n">conv_out</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">nnet</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">W</span><span class="p">,</span> <span class="n">border_mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>
        <span class="c1"># Add padding to get correct size</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">],</span> <span class="n">K</span><span class="o">.</span><span class="n">spatial_2d_padding</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">pad_height</span><span class="p">),</span> <span class="n">dim_ordering</span><span class="o">=</span><span class="s2">&quot;th&quot;</span><span class="p">))</span>

        <span class="c1"># Keras 2.0 but not sure</span>
        <span class="c1"># pad = K.function([self.x], K.spatial_2d_padding(</span>
        <span class="c1">#     self.x, padding=((pad_width, 0), (0, pad_height)), data_format=&quot;channels_first&quot;))</span>

        <span class="n">X_pad</span> <span class="o">=</span> <span class="n">pad</span><span class="p">([</span><span class="n">X</span><span class="p">])</span>
        <span class="c1"># Get Deconv output</span>
        <span class="n">deconv_func</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">],</span> <span class="n">conv_out</span><span class="p">)</span>
        <span class="n">X_deconv</span> <span class="o">=</span> <span class="n">deconv_func</span><span class="p">([</span><span class="n">X_pad</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">X_deconv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="p">(</span><span class="n">o_width</span><span class="p">,</span> <span class="n">o_height</span><span class="p">),</span> <span class="s2">&quot;Deconv output at </span><span class="si">%s</span><span class="s2"> has wrong size&quot;</span> <span class="o">%</span> <span class="n">lname</span>
        <span class="k">return</span> <span class="n">X_deconv</span>

    <span class="k">def</span> <span class="nf">_forward_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">):</span>

        <span class="c1"># For all layers up to the target layer</span>
        <span class="c1"># Store the max activation in switch</span>
        <span class="n">d_switch</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">layer_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target_layer</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnames</span><span class="p">[:</span><span class="n">layer_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># Get layer output</span>
            <span class="n">inc</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">lname</span><span class="p">]</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">lname</span><span class="p">]</span><span class="o">.</span><span class="n">output</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">([</span><span class="n">inc</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">()],</span> <span class="n">out</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">f</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;convolution2d&quot;</span> <span class="ow">in</span> <span class="n">lname</span><span class="p">:</span>
                <span class="n">d_switch</span><span class="p">[</span><span class="n">lname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">X</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d_switch</span>

    <span class="k">def</span> <span class="nf">_backward_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">,</span> <span class="n">d_switch</span><span class="p">,</span> <span class="n">feat_map</span><span class="p">):</span>
        <span class="c1"># Run deconv/maxunpooling until input pixel space</span>
        <span class="n">layer_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target_layer</span><span class="p">)</span>
        <span class="c1"># Get the output of the target_layer of interest</span>
        <span class="n">layer_output</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">()],</span> <span class="bp">self</span><span class="p">[</span><span class="n">target_layer</span><span class="p">]</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
        <span class="n">X_outl</span> <span class="o">=</span> <span class="n">layer_output</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Special case for the starting layer where we may want</span>
        <span class="c1"># to switchoff somes maps/ activations</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Deconvolving </span><span class="si">%s</span><span class="s2">...&quot;</span> <span class="o">%</span> <span class="n">target_layer</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;maxpooling2d&quot;</span> <span class="ow">in</span> <span class="n">target_layer</span><span class="p">:</span>
            <span class="n">X_maxunp</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">max_pool_2d_same_size</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">target_layer</span><span class="p">]</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">target_layer</span><span class="p">]</span><span class="o">.</span><span class="n">pool_size</span><span class="p">)</span>
            <span class="n">unpool_func</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">input</span><span class="p">],</span> <span class="n">X_maxunp</span><span class="p">)</span>
            <span class="n">X_outl</span> <span class="o">=</span> <span class="n">unpool_func</span><span class="p">([</span><span class="n">X</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">feat_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X_outl</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">feat_map</span><span class="p">:</span>
                        <span class="n">X_outl</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X_outl</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">iw</span><span class="p">,</span> <span class="n">ih</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">X_outl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">feat_map</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">argmax</span><span class="p">(),</span> <span class="n">X_outl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">feat_map</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X_outl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">feat_map</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
                    <span class="n">X_outl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">feat_map</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">X_outl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">feat_map</span><span class="p">,</span> <span class="n">iw</span><span class="p">,</span> <span class="n">ih</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">elif</span> <span class="s2">&quot;convolution2d&quot;</span> <span class="ow">in</span> <span class="n">target_layer</span><span class="p">:</span>
            <span class="n">X_outl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deconv</span><span class="p">(</span><span class="n">X_outl</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">,</span> <span class="n">d_switch</span><span class="p">,</span> <span class="n">feat_map</span><span class="o">=</span><span class="n">feat_map</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid layer name: </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> Can only handle maxpool and conv&quot;</span> <span class="o">%</span> <span class="n">target_layer</span><span class="p">)</span>
        <span class="c1"># Iterate over layers (deepest to shallowest)</span>
        <span class="k">for</span> <span class="n">lname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnames</span><span class="p">[:</span><span class="n">layer_index</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Deconvolving </span><span class="si">%s</span><span class="s2">...&quot;</span> <span class="o">%</span> <span class="n">lname</span><span class="p">)</span>
            <span class="c1"># Unpool, Deconv or do nothing</span>
            <span class="k">if</span> <span class="s2">&quot;maxpooling2d&quot;</span> <span class="ow">in</span> <span class="n">lname</span><span class="p">:</span>
                <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">lname</span><span class="p">]</span><span class="o">.</span><span class="n">pool_size</span>
                <span class="n">uppool</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">],</span> <span class="n">K</span><span class="o">.</span><span class="n">resize_images</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="s2">&quot;th&quot;</span><span class="p">))</span>
                <span class="n">X_outl</span> <span class="o">=</span> <span class="n">uppool</span><span class="p">([</span><span class="n">X_outl</span><span class="p">])</span>

            <span class="k">elif</span> <span class="s2">&quot;convolution2d&quot;</span> <span class="ow">in</span> <span class="n">lname</span><span class="p">:</span>
                <span class="n">X_outl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deconv</span><span class="p">(</span><span class="n">X_outl</span><span class="p">,</span> <span class="n">lname</span><span class="p">,</span> <span class="n">d_switch</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot;padding&quot;</span> <span class="ow">in</span> <span class="n">lname</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="s2">&quot;batchnormalization&quot;</span> <span class="ow">in</span> <span class="n">lname</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="s2">&quot;input&quot;</span> <span class="ow">in</span> <span class="n">lname</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid layer name: </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> Can only handle maxpool, conv, bacthnormalization and padding layer&quot;</span> <span class="o">%</span> <span class="n">lname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">X_outl</span>

<div class="viewcode-block" id="DeconvNet.get_layers"><a class="viewcode-back" href="../../../ai4materials.interpretation.deconv_resp_maps.html#ai4materials.interpretation.deconv_resp_maps.DeconvNet.get_layers">[docs]</a>    <span class="k">def</span> <span class="nf">get_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">list_layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span>
        <span class="n">list_layers_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">list_layers</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">list_layers_name</span></div>

<div class="viewcode-block" id="DeconvNet.get_deconv"><a class="viewcode-back" href="../../../ai4materials.interpretation.deconv_resp_maps.html#ai4materials.interpretation.deconv_resp_maps.DeconvNet.get_deconv">[docs]</a>    <span class="k">def</span> <span class="nf">get_deconv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">,</span> <span class="n">feat_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># First make predictions to get feature maps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="c1"># Forward pass storing switches</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Starting forward pass...&quot;</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">d_switch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_forward_pass</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Forward pass completed in </span><span class="si">%d</span><span class="s1">s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">))</span>
        <span class="c1"># Then deconvolve starting from target layer</span>
        <span class="n">X_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backward_pass</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">target_layer</span><span class="p">,</span> <span class="n">d_switch</span><span class="p">,</span> <span class="n">feat_map</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">X_out</span></div></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2018, Angelo Ziletti.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>