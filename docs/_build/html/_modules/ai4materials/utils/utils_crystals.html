

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ai4materials.utils.utils_crystals &mdash; ai4materials v0.1.0</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="ai4materials v0.1.0" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/>
    <link href="../../../_static/nomad-analytics.css" rel="stylesheet" type="text/css">


  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> ai4materials
          

          
            
            <img src="../../../_static/ai_for_materials_logo.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.dataprocessing.html">Data preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.descriptors.html">Representing crystal structures: descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.wrappers.html">Creating and loading materials science datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.models.html">Regression and classification models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.interpretation.html">Neural network interpretation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ai4materials.utils.html">Utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../history.html">History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ai4materials</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>ai4materials.utils.utils_crystals</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ai4materials.utils.utils_crystals</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding=utf-8</span>
<span class="c1"># Copyright 2016-2018 Angelo Ziletti</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Angelo Ziletti&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2018, Angelo Ziletti&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Angelo Ziletti&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;ziletti@fhi-berlin.mpg.de&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;23/09/18&quot;</span>

<span class="kn">from</span> <span class="nn">ase.neighborlist</span> <span class="k">import</span> <span class="n">NeighborList</span>
<span class="kn">from</span> <span class="nn">ase.build</span> <span class="k">import</span> <span class="n">find_optimal_cell_shape_pure_python</span>
<span class="kn">from</span> <span class="nn">ase.build</span> <span class="k">import</span> <span class="n">get_deviation_from_optimal_cell_shape</span>
<span class="kn">from</span> <span class="nn">ase.build</span> <span class="k">import</span> <span class="n">make_supercell</span>
<span class="kn">from</span> <span class="nn">ase.spacegroup</span> <span class="k">import</span> <span class="n">get_spacegroup</span> <span class="k">as</span> <span class="n">ase_get_spacegroup</span>
<span class="kn">import</span> <span class="nn">ase</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">cos</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sin</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.ase</span> <span class="k">import</span> <span class="n">AseAtomsAdaptor</span>
<span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="k">import</span> <span class="n">SpacegroupAnalyzer</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="k">import</span> <span class="n">Structure</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.lattice</span> <span class="k">import</span> <span class="n">Lattice</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">constants</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">izip</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">permutations</span>
<span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">Decimal</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">ai4materials.utils.utils_binaries</span> <span class="k">import</span> <span class="n">get_chemical_formula_binaries</span>
<span class="kn">import</span> <span class="nn">ai4materials.utils.unit_conversion</span> <span class="k">as</span> <span class="nn">uc</span>
<span class="kn">from</span> <span class="nn">ai4materials.utils.utils_config</span> <span class="k">import</span> <span class="n">get_data_filename</span>
<span class="kn">import</span> <span class="nn">scipy.misc</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">spglib</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">pint</span> <span class="k">import</span> <span class="n">UnitRegistry</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;ai4materials&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="get_spacegroup_analyzer"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.get_spacegroup_analyzer">[docs]</a><span class="k">def</span> <span class="nf">get_spacegroup_analyzer</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=-</span><span class="mf">1.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given an ASE structure and a symprec, return the SpacegroupAnalyzer.\n</span>

<span class="sd">    The SpacegroupAnalyzer is the object used in pymatgen to detect crystal symmetries: \n</span>
<span class="sd">    http://pymatgen.org/_modules/pymatgen/symmetry/analyzer.html</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms` object</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    symprec: list of floats</span>
<span class="sd">        Tolerance for symmetry finding. According to the pymatgen documentation: \n</span>
<span class="sd">        A value of 1e-3 is fairly strict and works well for properly refined</span>
<span class="sd">        structures with atoms in the proper symmetry coordinates. For</span>
<span class="sd">        structures with slight deviations from their proper atomic</span>
<span class="sd">        positions (e.g., structures relaxed with electronic structure</span>
<span class="sd">        codes), a looser tolerance of 0.1 (the value used in Materials</span>
<span class="sd">        Project) is often needed.</span>

<span class="sd">    angle_tolerance: float</span>
<span class="sd">        Tolerance of angle between lattice vectors in degrees to be tolerated in the symmetry finding.</span>
<span class="sd">        It is used by Spglib. By specifying a negative value, the behavior becomes the same as usual functions.</span>
<span class="sd">        For more info: https://atztogo.github.io/spglib/variable.html#variables-angle-tolerance</span>

<span class="sd">    Returns:</span>

<span class="sd">    `pymatgen.SpacegroupAnalyzer` object</span>
<span class="sd">        Return the SpacegroupAnalyzer of pymatgen.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">symprec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">symprec</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-03</span><span class="p">,</span> <span class="mf">1e-06</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symprec</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">symprec</span> <span class="o">=</span> <span class="p">[</span><span class="n">symprec</span><span class="p">]</span>

    <span class="n">spacegroup_analyzer</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">symprec_</span> <span class="ow">in</span> <span class="n">symprec</span><span class="p">:</span>
        <span class="n">spacegroup_analyzer</span><span class="p">[</span><span class="n">symprec_</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">AseAtomsAdaptor</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="n">symprec</span><span class="o">=</span><span class="n">symprec_</span><span class="p">,</span>
                                                           <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spacegroup_analyzer</span></div>


<div class="viewcode-block" id="get_spacegroup"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.get_spacegroup">[docs]</a><span class="k">def</span> <span class="nf">get_spacegroup</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given an ASE structure and a (list of) symmetry threshold, return the spacegroup number.\n</span>

<span class="sd">    Internally, it uses the SpacegroupAnalyzer is the object used in pymatgen to detect crystal symmetries: \n</span>
<span class="sd">    http://pymatgen.org/_modules/pymatgen/symmetry/analyzer.html</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: ``ase.Atoms`` object</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    symprec: list of floats</span>
<span class="sd">        Tolerance for symmetry finding. According to the pymatgen documentation: \n</span>
<span class="sd">        A value of 1e-3 is fairly strict and works well for properly refined</span>
<span class="sd">        structures with atoms in the proper symmetry coordinates. For</span>
<span class="sd">        structures with slight deviations from their proper atomic</span>
<span class="sd">        positions (e.g., structures relaxed with electronic structure</span>
<span class="sd">        codes), a looser tolerance of 0.1 (the value used in Materials</span>
<span class="sd">        Project) is often needed.</span>

<span class="sd">    Returns:</span>

<span class="sd">    list of floats</span>
<span class="sd">        Spacegroup numbers obtained for the given symprec thresholds.</span>

<span class="sd">    .. seealso:: Internally, it uses the SpacegroupAnalyzer object of pymatgen; see</span>
<span class="sd">        :py:mod:`ai4materials.utils.utils_crystals.get_spacegroup_analyzer`</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">space_group_analyzer</span> <span class="o">=</span> <span class="n">get_spacegroup_analyzer</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">)</span>

    <span class="n">spacegroup_nbs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">space_group_analyzer</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">spacegroup_nb</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get_space_group_number</span><span class="p">()</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;spacegroup_nb&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">spacegroup_nb</span>
        <span class="n">spacegroup_nbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spacegroup_nb</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spacegroup_nbs</span></div>


<div class="viewcode-block" id="get_conventional_std_cell"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.get_conventional_std_cell">[docs]</a><span class="k">def</span> <span class="nf">get_conventional_std_cell</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given an ASE atoms object, return the ASE atoms object in the conventional standard cell.</span>

<span class="sd">    It uses symmetries to find the conventional standard cell.</span>
<span class="sd">    In particular, it gives a structure with a conventional cell according to the standard defined in</span>
<span class="sd">    W. Setyawan, and S. Curtarolo, Comput. Mater. Sci.49(2), 299-312 (2010). \n</span>

<span class="sd">    This is simply a wrapper around the pymatgen implementation:</span>
<span class="sd">    http://pymatgen.org/_modules/pymatgen/symmetry/analyzer.html</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms` object</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    Returns:</span>

<span class="sd">    `ase.Atoms` object</span>
<span class="sd">        Return the structure in a conventional cell.</span>

<span class="sd">    .. seealso:: To create a standard cell that it is independent from symmetry operations use</span>
<span class="sd">        :py:mod:`ai4materials.utils.utils_crystals.get_conventional_std_cell_no_sym`</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># save atoms.info dict otherwise it gets lost in the conversion</span>
    <span class="n">atoms_info</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span>
    <span class="n">mg_structure</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">finder</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">mg_structure</span><span class="p">)</span>

    <span class="n">mg_structure</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">get_conventional_standard_structure</span><span class="p">()</span>
    <span class="n">conventional_standard_atoms</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">(</span><span class="n">mg_structure</span><span class="p">)</span>

    <span class="n">conventional_standard_atoms</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">atoms_info</span>

    <span class="k">return</span> <span class="n">conventional_standard_atoms</span></div>


<div class="viewcode-block" id="get_conventional_std_cell_no_sym"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.get_conventional_std_cell_no_sym">[docs]</a><span class="k">def</span> <span class="nf">get_conventional_std_cell_no_sym</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given an ASE atoms object, return the ASE atoms object in the conventional standard cell.</span>

<span class="sd">    It does NOT use symmetries to obtain the standard cell. \n</span>

<span class="sd">    Gives a structure with a conventional cell according to the standard defined for TRICLINIC cells in</span>
<span class="sd">    W. Setyawan, and S. Curtarolo, Comput. Mater. Sci.49(2), 299-312 (2010). \n</span>
<span class="sd">    The triclinic convention is employed to make sure that no information on the symmetry of the lattice</span>
<span class="sd">    is used in the generation of the standard cell. \n</span>

<span class="sd">    The code is taken from the triclinic cell case in pymatgen:</span>
<span class="sd">    http://pymatgen.org/_modules/pymatgen/symmetry/analyzer.html</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms` object</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    Returns:</span>

<span class="sd">    `ase.Atoms` object</span>
<span class="sd">        Return the structure in a conventional cell (the convention used is the one for triclinic cells)</span>

<span class="sd">    .. seealso:: To create a standard cell that exploits symmetry information use</span>
<span class="sd">        :py:mod:`ai4materials.utils.utils_crystals.get_conventional_std_cell`</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># save atoms.info dict otherwise it gets lost in the conversion</span>
    <span class="n">atoms_info</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span>
    <span class="n">mg_structure</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">finder</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">mg_structure</span><span class="p">)</span>

    <span class="c1"># get structure in the spglib format</span>
    <span class="c1"># according to the Spglib documentation</span>
    <span class="c1"># (https://atztogo.github.io/spglib/python-spglib.html?highlight=standardize_cell#standardize-cell)</span>
    <span class="c1"># ‘no_idealize=True’ disables to idealize lengths and angles of basis vectors and positions of atoms according to crystal symmetry</span>
    <span class="c1"># the structure is not refined and thus symmetries are not used</span>
    <span class="n">lattice</span><span class="p">,</span> <span class="n">scaled_positions</span><span class="p">,</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">standardize_cell</span><span class="p">(</span><span class="n">finder</span><span class="o">.</span><span class="n">_cell</span><span class="p">,</span> <span class="n">to_primitive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">no_idealize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">species</span> <span class="o">=</span> <span class="p">[</span><span class="n">finder</span><span class="o">.</span><span class="n">_unique_species</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">]</span>
    <span class="n">struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">scaled_positions</span><span class="p">)</span><span class="o">.</span><span class="n">get_sorted_structure</span><span class="p">()</span>

    <span class="c1"># this is the convention for triclinic cells in pymatgen</span>
    <span class="c1"># http://pymatgen.org/_modules/pymatgen/symmetry/analyzer.html</span>
    <span class="n">latt</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">lattice</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">latt</span><span class="o">.</span><span class="n">lengths_and_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">180</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">latt</span><span class="o">.</span><span class="n">lengths_and_angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">new_matrix</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">transf</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">test_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">],</span>
                   <span class="p">[</span><span class="n">c</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span> <span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="n">c</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                       <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span>
                           <span class="n">gamma</span><span class="p">))</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)]]</span>

    <span class="k">def</span> <span class="nf">is_all_acute_or_obtuse</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">recp_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Lattice</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">recp_angles</span> <span class="o">&lt;=</span> <span class="mi">90</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">recp_angles</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_all_acute_or_obtuse</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">):</span>
        <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">test_matrix</span>

    <span class="n">test_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">],</span>
                   <span class="p">[</span><span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span> <span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                       <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span>
                           <span class="n">gamma</span><span class="p">))</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)]]</span>

    <span class="k">if</span> <span class="n">is_all_acute_or_obtuse</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">):</span>
        <span class="n">transf</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">test_matrix</span>

    <span class="n">test_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">],</span>
                   <span class="p">[</span><span class="n">c</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span> <span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="n">c</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                       <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span>
                           <span class="n">gamma</span><span class="p">))</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)]]</span>

    <span class="k">if</span> <span class="n">is_all_acute_or_obtuse</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">):</span>
        <span class="n">transf</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">test_matrix</span>

    <span class="n">test_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">],</span>
                   <span class="p">[</span><span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span> <span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                       <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span>
                           <span class="n">gamma</span><span class="p">))</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)]]</span>
    <span class="k">if</span> <span class="n">is_all_acute_or_obtuse</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">):</span>
        <span class="n">transf</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">test_matrix</span>

    <span class="n">latt</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">new_matrix</span><span class="p">)</span>

    <span class="n">new_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">new_struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">latt</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">,</span> <span class="n">new_coords</span><span class="p">,</span> <span class="n">site_properties</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">site_properties</span><span class="p">,</span>
                           <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">get_sorted_structure</span><span class="p">()</span>

    <span class="c1"># put the results back in an ASE structure</span>
    <span class="n">conventional_standard_atoms</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">(</span><span class="n">new_struct</span><span class="p">)</span>
    <span class="n">conventional_standard_atoms</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">atoms_info</span>

    <span class="k">return</span> <span class="n">conventional_standard_atoms</span></div>


<div class="viewcode-block" id="get_primitive_std_cell"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.get_primitive_std_cell">[docs]</a><span class="k">def</span> <span class="nf">get_primitive_std_cell</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given an ASE atoms object, return the ASE atoms object in the primitive standard cell.</span>

<span class="sd">    It uses symmetries to find the primitive standard cell.</span>
<span class="sd">    In particular, it gives a structure with a conventional cell according to the standard defined in</span>
<span class="sd">    W. Setyawan, and S. Curtarolo, Comput. Mater. Sci.49(2), 299-312 (2010). \n</span>

<span class="sd">    This is simply a wrapper around the pymatgen implementation:</span>
<span class="sd">    http://pymatgen.org/_modules/pymatgen/symmetry/analyzer.html</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms` object</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    Returns:</span>

<span class="sd">    `ase.Atoms` object</span>
<span class="sd">        Return the structure in the primitive cell</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># save atoms.info dict otherwise it gets lost in the conversion</span>
    <span class="n">atoms_info</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span>
    <span class="n">mg_structure</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="n">finder</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">mg_structure</span><span class="p">)</span>
    <span class="n">mg_structure</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">get_primitive_standard_structure</span><span class="p">()</span>
    <span class="n">primitive_standard_atoms</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">(</span><span class="n">mg_structure</span><span class="p">)</span>
    <span class="n">primitive_standard_atoms</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">atoms_info</span>

    <span class="k">return</span> <span class="n">primitive_standard_atoms</span></div>


<div class="viewcode-block" id="modify_crystal"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.modify_crystal">[docs]</a><span class="k">def</span> <span class="nf">modify_crystal</span><span class="p">(</span><span class="n">ase_atoms</span><span class="p">,</span> <span class="n">function_to_apply</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply a transformation to a crystal structure&quot;&quot;&quot;</span>
    <span class="n">ase_atoms</span> <span class="o">=</span> <span class="n">function_to_apply</span><span class="p">(</span><span class="n">ase_atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ase_atoms</span></div>


<div class="viewcode-block" id="nb_of_replicas"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.nb_of_replicas">[docs]</a><span class="k">def</span> <span class="nf">nb_of_replicas</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">create_replicas_by</span><span class="p">,</span> <span class="n">min_nb_atoms</span><span class="p">,</span> <span class="n">target_nb_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_diff_nb_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">target_replicas</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the number of replicas of the input cell in each direction.</span>

<span class="sd">    The number of replicas that are returned will be later used by</span>
<span class="sd">    :py:mod:`ai4materials.utils.utils_crystals.create_supercell`</span>
<span class="sd">    to actually make a supercell.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms`</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    create_replicas_by: { &#39;nb_atoms&#39;, &#39;radius&#39;, &#39;user-defined&#39;}</span>
<span class="sd">        Method to calculate the replicas. \n</span>
<span class="sd">        `create_replicas_by` = &#39;nb_atoms&#39; creates supercells &#39;naively&#39; as cubic as possible with the number of atoms</span>
<span class="sd">        as close as possible to `target_nb_atoms`. \n</span>
<span class="sd">        `create_replicas_by` = &#39;radius&#39; creates supercells &#39;naively&#39; as cubic as possible with the number of atoms</span>
<span class="sd">        with the given radius. \n</span>

<span class="sd">    min_nb_atoms: int</span>
<span class="sd">        Minimum number of atoms for the replicated structure.</span>
<span class="sd">        If the resulting structure has less atoms, an error will be raised.</span>

<span class="sd">    target_nb_atoms: int, optional</span>
<span class="sd">        Target number of atoms in the supercell created. The actual number of atoms might differ from it.</span>
<span class="sd">        See also `max_diff_nb_atoms` below. \n</span>
<span class="sd">        Used only if `create_replicas_by`=&#39;nb_atoms&#39;.</span>

<span class="sd">    max_diff_nb_atoms: int, optional</span>
<span class="sd">        Maximum (absolute) difference between the `target_nb_atoms` and the actual number of atoms present</span>
<span class="sd">        in the supercell. If the difference is larger, an error will be raised.</span>
<span class="sd">        Used only if `create_replicas_by`=&#39;nb_atoms&#39;.</span>

<span class="sd">    radius: float, optional</span>
<span class="sd">        Used only if `create_replicas_by`=&#39;radius&#39;.</span>

<span class="sd">    target_replicas: int or list/tuple of int, optional</span>
<span class="sd">        Number of replicas of the created supercell. \n</span>
<span class="sd">        `target_replicas` = 3 replicates the cell 3 times along the 3 directions \n</span>
<span class="sd">        `target_replicas` = (4,2,2) replicates the cell 4 times along the 1st direction, and 2 times along the other</span>
<span class="sd">        two directions. \n</span>
<span class="sd">        Used only if `create_replicas_by`=&#39;user-defined&#39;.</span>

<span class="sd">    Returns:</span>

<span class="sd">    list of int</span>
<span class="sd">        List of three integers corresponding to the number of repetition of the input cell along</span>
<span class="sd">        the three dimensions.</span>

<span class="sd">    .. seealso:: Algorithms for supercell determination are found in</span>
<span class="sd">        :py:mod:`ai4materials.utils.utils_crystals.nb_atoms_to_replicas` and</span>
<span class="sd">        :py:mod:`ai4materials.utils.utils_crystals.radius_to_replicas`.\n</span>
<span class="sd">        Starting from the number of replicas here, the actual supercell is made in</span>
<span class="sd">        :py:mod:`ai4materials.utils.utils_crystals.create_supercell`</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">create_replicas_by</span> <span class="o">==</span> <span class="s1">&#39;nb_atoms&#39;</span><span class="p">:</span>
        <span class="n">replicas</span> <span class="o">=</span> <span class="n">nb_atoms_to_replicas</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">min_nb_atoms</span><span class="p">,</span> <span class="n">target_nb_atoms</span><span class="p">,</span> <span class="n">max_diff_nb_atoms</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">create_replicas_by</span> <span class="o">==</span> <span class="s1">&#39;radius&#39;</span><span class="p">:</span>
        <span class="n">replicas</span> <span class="o">=</span> <span class="n">radius_to_replicas</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">min_nb_atoms</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">create_replicas_by</span> <span class="o">==</span> <span class="s1">&#39;user-defined&#39;</span><span class="p">:</span>
        <span class="n">replicas</span> <span class="o">=</span> <span class="n">target_replicas</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid value for create_replicas_by. Possible values are nb_atoms, radius, user-defined.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">replicas</span></div>


<div class="viewcode-block" id="spacegroup_a_to_spacegroup_b"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.spacegroup_a_to_spacegroup_b">[docs]</a><span class="k">def</span> <span class="nf">spacegroup_a_to_spacegroup_b</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">spgroup_a</span><span class="p">,</span> <span class="n">spgroup_b</span><span class="p">,</span> <span class="n">target_b_contribution</span><span class="p">,</span> <span class="n">create_replicas_by</span><span class="p">,</span>
                                 <span class="n">min_nb_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_nb_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_diff_nb_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">target_replicas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_rel_error</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove central atoms for bcc to sc&quot;&quot;&quot;</span>

    <span class="c1"># get number of replicas</span>
    <span class="n">replicas</span> <span class="o">=</span> <span class="n">nb_of_replicas</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">create_replicas_by</span><span class="o">=</span><span class="n">create_replicas_by</span><span class="p">,</span> <span class="n">min_nb_atoms</span><span class="o">=</span><span class="n">min_nb_atoms</span><span class="p">,</span>
                              <span class="n">target_nb_atoms</span><span class="o">=</span><span class="n">target_nb_atoms</span><span class="p">,</span> <span class="n">max_diff_nb_atoms</span><span class="o">=</span><span class="n">max_diff_nb_atoms</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
                              <span class="n">target_replicas</span><span class="o">=</span><span class="n">target_replicas</span><span class="p">)</span>

    <span class="n">atoms</span> <span class="o">=</span> <span class="n">standardize_cell</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># make a spgroup_a-type supercell before removing atoms</span>
    <span class="n">atoms_a</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">atoms_a</span> <span class="o">=</span> <span class="n">atoms_a</span> <span class="o">*</span> <span class="n">replicas</span>

    <span class="c1"># check initial spacegroup</span>
    <span class="n">mg_structure</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">finder</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">mg_structure</span><span class="p">)</span>
    <span class="n">init_spgroup</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">get_space_group_symbol</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">init_spgroup</span> <span class="o">==</span> <span class="n">spgroup_a</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initial spacegroup is </span><span class="si">{0}</span><span class="s1"> as expected&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">init_spgroup</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Initial spacegroup is </span><span class="si">{0}</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;while the expected spacegroup is </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">init_spgroup</span><span class="p">,</span> <span class="n">spgroup_a</span><span class="p">))</span>

    <span class="c1"># initially the mix structure has all the spgroup_a atoms</span>
    <span class="n">atoms_mix</span> <span class="o">=</span> <span class="n">atoms_a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">idx_remove_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">TOL</span> <span class="o">=</span> <span class="mf">1e-03</span>

    <span class="k">if</span> <span class="n">spgroup_a</span> <span class="o">==</span> <span class="s1">&#39;Im-3m&#39;</span> <span class="ow">and</span> <span class="n">spgroup_b</span> <span class="o">==</span> <span class="s1">&#39;Pm-3m&#39;</span><span class="p">:</span>
        <span class="c1"># from bcc to simple cubic</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">get_number_of_atoms</span><span class="p">()):</span>
            <span class="c1"># deleting all atoms from spgroup_a to go in spgroup_b</span>
            <span class="c1"># removing the atoms that are in position (0.0, 0.0, 0.0)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">TOL</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">TOL</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span>
                    <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">TOL</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx_remove_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">spgroup_a</span> <span class="o">==</span> <span class="s1">&#39;Fd-3m&#39;</span> <span class="ow">and</span> <span class="n">spgroup_b</span> <span class="o">==</span> <span class="s1">&#39;Fm-3m&#39;</span><span class="p">:</span>
        <span class="c1"># from diamond to fcc</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">get_number_of_atoms</span><span class="p">()):</span>
            <span class="c1"># deleting all atoms from spgroup_a to go in spgroup_b</span>
            <span class="c1"># removing the atoms that are &quot;inside&quot; the cube</span>
            <span class="c1"># keep only the atoms that have one coordinate which is</span>
            <span class="c1"># 1/2 of the cell length or position (0.0, 0.0, 0.0)</span>
            <span class="n">cell_length</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_cell_lengths_and_angles</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cell_length</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">TOL</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span>
                <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cell_length</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">TOL</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span>
                    <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">cell_length</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">TOL</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">TOL</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">TOL</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span>
                    <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">TOL</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx_remove_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Transformation from spacegroup </span><span class="si">{0}</span><span class="s2"> to spacegroup </span><span class="si">{1}</span><span class="s2">&quot;</span>
                                  <span class="s2">&quot;is not implemented&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spgroup_a</span><span class="p">,</span> <span class="n">spgroup_b</span><span class="p">))</span>

    <span class="c1"># delete all the indices added to the list</span>
    <span class="k">del</span> <span class="n">atoms</span><span class="p">[[</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">idx_remove_list</span><span class="p">]]</span>

    <span class="n">atoms_b</span> <span class="o">=</span> <span class="n">atoms</span> <span class="o">*</span> <span class="n">replicas</span>

    <span class="c1"># check final spacegroup</span>
    <span class="n">mg_structure</span> <span class="o">=</span> <span class="n">AseAtomsAdaptor</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">atoms_b</span><span class="p">)</span>
    <span class="n">finder</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">mg_structure</span><span class="p">)</span>
    <span class="n">final_spgroup</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">get_space_group_symbol</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">final_spgroup</span> <span class="o">==</span> <span class="n">spgroup_b</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Final spacegroup is </span><span class="si">{0}</span><span class="s1"> as expected&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">final_spgroup</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Final spacegroup is </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">final_spgroup</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Expected final spacegroup is </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spgroup_b</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The transformation provided does not give the expected final &quot;</span>
                        <span class="s2">&quot; spacegroup. Expected: </span><span class="si">{0}</span><span class="s2">; obtained: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spgroup_b</span><span class="p">,</span> <span class="n">final_spgroup</span><span class="p">))</span>

    <span class="c1"># find the rows that are in bcc-type supercell and not in sc</span>
    <span class="n">atoms_a_rows</span> <span class="o">=</span> <span class="n">atoms_a</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">view</span><span class="p">([(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">atoms_a</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span> <span class="o">*</span> <span class="n">atoms_a</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">atoms_b_rows</span> <span class="o">=</span> <span class="n">atoms_b</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">view</span><span class="p">([(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">atoms_b</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span> <span class="o">*</span> <span class="n">atoms_b</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">a_b_diff_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">atoms_a_rows</span><span class="p">,</span> <span class="n">atoms_b_rows</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">atoms_a</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                                                                                  <span class="n">atoms_a</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span>
                                                                                                      <span class="mi">1</span><span class="p">])</span>

    <span class="n">atoms_a_only_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">atoms_a</span><span class="o">.</span><span class="n">get_number_of_atoms</span><span class="p">()):</span>
        <span class="k">for</span> <span class="n">row_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a_b_diff_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">atoms_a</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">a_b_diff_pos</span><span class="p">[</span><span class="n">row_idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-03</span><span class="p">):</span>
                <span class="n">atoms_a_only_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="c1"># take a random subset of atoms to remove</span>
    <span class="n">nb_atoms_to_rm</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms_a_only_ids</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_b_contribution</span><span class="p">)</span>
    <span class="n">actual_b_contribution</span> <span class="o">=</span> <span class="n">nb_atoms_to_rm</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms_a_only_ids</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">target_b_contribution</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">rel_error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target_b_contribution</span> <span class="o">-</span> <span class="n">actual_b_contribution</span><span class="p">)</span> <span class="o">/</span> <span class="n">target_b_contribution</span>

        <span class="k">if</span> <span class="n">rel_error</span> <span class="o">&gt;</span> <span class="n">max_rel_error</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Difference between target and actual vacancy ratio &quot;</span>
                           <span class="s2">&quot;bigger than the threshold (</span><span class="si">{0}</span><span class="s2">%).</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;Target/actual vacancy ratio: </span><span class="si">{1}</span><span class="s2">%/</span><span class="si">{2}</span><span class="s2">%.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_rel_error</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">,</span>
                                                                            <span class="n">target_b_contribution</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">,</span>
                                                                            <span class="n">actual_b_contribution</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">))</span>

    <span class="c1"># random sampling of the list without replacement</span>
    <span class="n">atoms_a_only_ids_subset</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">atoms_a_only_ids</span><span class="p">,</span> <span class="n">nb_atoms_to_rm</span><span class="p">)</span>

    <span class="c1"># remove atoms from the bcc_atoms_only_ids</span>
    <span class="k">del</span> <span class="n">atoms_mix</span><span class="p">[[</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms_mix</span> <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">atoms_a_only_ids_subset</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">atoms_mix</span></div>


<div class="viewcode-block" id="nb_atoms_to_replicas"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.nb_atoms_to_replicas">[docs]</a><span class="k">def</span> <span class="nf">nb_atoms_to_replicas</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">min_nb_atoms</span><span class="p">,</span> <span class="n">target_nb_atoms</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_diff_nb_atoms</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the replication that gives a supercell &#39;naively&#39; as cubic as possible with the number of atoms</span>
<span class="sd">        as close as possible to `target_nb_atoms`.</span>

<span class="sd">    The algorithm calculates the extension of the structure along the 3 dimensions and add a repetition</span>
<span class="sd">    along the direction that has the smaller extension.</span>

<span class="sd">    For information regarding the parameters, please refer to</span>
<span class="sd">    :py:mod:`ai4materials.utils.utils_crystals.nb_of_replicas`.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nb_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">atoms_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">replicas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms_new</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">target_nb_atoms</span><span class="p">:</span>
        <span class="n">max_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">atoms_new</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">atoms_new</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="n">smallest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">max_distance</span><span class="p">)</span>
        <span class="n">replicas</span><span class="p">[</span><span class="n">smallest_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">replicas</span><span class="p">[</span><span class="n">smallest_idx</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">atoms_new</span> <span class="o">=</span> <span class="n">atoms</span> <span class="o">*</span> <span class="n">replicas</span>

    <span class="n">nb_atoms_replicas</span> <span class="o">=</span> <span class="n">nb_atoms</span> <span class="o">*</span> <span class="n">replicas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">replicas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">replicas</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">diff_nb_atoms</span> <span class="o">=</span> <span class="n">target_nb_atoms</span> <span class="o">-</span> <span class="n">nb_atoms_replicas</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">diff_nb_atoms</span> <span class="o">&gt;</span> <span class="n">max_diff_nb_atoms</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Difference between target and actual nb_atoms in &quot;</span>
                           <span class="s2">&quot;supercell generation is greater than threshold. </span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;Initial nb_atoms: </span><span class="si">{0}</span><span class="s2">; target nb_atoms: </span><span class="si">{1}</span><span class="s2">; actual nb_atoms: </span><span class="si">{2}</span><span class="s2">; </span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;actual_nb_difference: </span><span class="si">{3}</span><span class="s2">; max nb_difference: </span><span class="si">{4}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;replicas: </span><span class="si">{5}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nb_atoms</span><span class="p">,</span> <span class="n">target_nb_atoms</span><span class="p">,</span> <span class="n">nb_atoms_replicas</span><span class="p">,</span> <span class="n">diff_nb_atoms</span><span class="p">,</span>
                                                  <span class="n">max_diff_nb_atoms</span><span class="p">,</span> <span class="n">replicas</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">nb_atoms_replicas</span> <span class="o">&lt;</span> <span class="n">min_nb_atoms</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Structure has less than the required number of atoms. &quot;</span>
                         <span class="s2">&quot;It has </span><span class="si">{0}</span><span class="s2"> atoms instead of </span><span class="si">{1}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nb_atoms_replicas</span><span class="p">,</span> <span class="n">min_nb_atoms</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">replicas</span></div>


<div class="viewcode-block" id="radius_to_replicas"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.radius_to_replicas">[docs]</a><span class="k">def</span> <span class="nf">radius_to_replicas</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">min_nb_atoms</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the replication that gives a supercell &#39;naively&#39; as cubic as possible to the required `radius`.</span>

<span class="sd">    It approaches `radius` from below.</span>

<span class="sd">    The algorithm calculates how many cells can be fit within the specified radius for each dimension.</span>

<span class="sd">    For information regarding the parameters, please refer to</span>
<span class="sd">    :py:mod:`ai4materials.utils.utils_crystals.nb_of_replicas`.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cell_lengths</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_cell_lengths_and_angles</span><span class="p">()[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">replicas</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">radius_i</span> <span class="o">//</span> <span class="n">cell_length</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell_length</span><span class="p">,</span> <span class="n">radius_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cell_lengths</span><span class="p">,</span> <span class="n">radius</span><span class="p">)]</span>

    <span class="n">nb_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">nb_atoms_replicas</span> <span class="o">=</span> <span class="n">nb_atoms</span> <span class="o">*</span> <span class="n">replicas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">replicas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">replicas</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">nb_atoms_replicas</span> <span class="o">&lt;</span> <span class="n">min_nb_atoms</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Structure has less than the required number of atoms. &quot;</span>
                         <span class="s2">&quot;It has </span><span class="si">{0}</span><span class="s2"> atoms instead of </span><span class="si">{1}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nb_atoms_replicas</span><span class="p">,</span> <span class="n">min_nb_atoms</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">replicas</span></div>


<span class="c1"># def _align_supercell(atoms):</span>
<span class="c1">#     &quot;&quot;&quot;Coherent point drift registration. Only a stub, it does not work.&quot;&quot;&quot;</span>
<span class="c1">#     import pycpd</span>
<span class="c1">#     from functools import partial</span>
<span class="c1">#</span>
<span class="c1">#     phi = np.random.uniform() * 360.0</span>
<span class="c1">#     theta = np.random.uniform() * 180.0</span>
<span class="c1">#     psi = np.random.uniform() * 360.0</span>
<span class="c1">#     atoms = rotate_atoms(atoms, phi=phi, theta=theta, psi=psi)</span>
<span class="c1">#</span>
<span class="c1">#     logger.debug(&quot;Euler angles for rotation. phi: {}, theta {}, psi {}&quot;.format(phi, theta, psi))</span>
<span class="c1">#</span>
<span class="c1">#     positions = atoms.get_positions()</span>
<span class="c1">#     atoms_rot = rotate_atoms(atoms, phi=phi, theta=theta, psi=psi)</span>
<span class="c1">#     rotated_positions = atoms_rot.get_positions()</span>
<span class="c1">#</span>
<span class="c1">#     def visualize(iteration, error, coord, coord_rot, ax_plot):</span>
<span class="c1">#         plt.cla()</span>
<span class="c1">#         ax_plot.scatter(coord[:, 0], coord[:, 1], coord[:, 2], color=&#39;red&#39;)</span>
<span class="c1">#         ax_plot.scatter(coord_rot[:, 0], coord_rot[:, 1], coord_rot[:, 2], color=&#39;blue&#39;)</span>
<span class="c1">#         plt.draw()</span>
<span class="c1">#         print(&quot;iteration %d, error %.5f&quot; % (iteration, error))</span>
<span class="c1">#         plt.pause(0.001)</span>
<span class="c1">#</span>
<span class="c1">#     fig = plt.figure()</span>
<span class="c1">#     ax = fig.add_subplot(111, projection=&#39;3d&#39;)</span>
<span class="c1">#     callback = partial(visualize, ax_plots=ax)</span>
<span class="c1">#</span>
<span class="c1">#     reg = pycpd.rigid_registration(positions, rotated_positions, maxIterations=1e6, tolerance=1.e-10)</span>
<span class="c1">#     reg.register(callback)</span>
<span class="c1">#     plt.show()</span>


<div class="viewcode-block" id="standardize_cell"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.standardize_cell">[docs]</a><span class="k">def</span> <span class="nf">standardize_cell</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Standardize the cell of the atomic structure.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms`</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    cell_type: { &#39;standard&#39;, &#39;standard_no_symmetries&#39;, &#39;primitive&#39;, None}</span>
<span class="sd">        Starting from the input cell, creates a standard cell according to same standards</span>
<span class="sd">        before the supercell generation. \n</span>
<span class="sd">        `cell_type` = &#39;standard&#39; creates a standard conventional cell.</span>
<span class="sd">        See :py:mod:`ai4materials.utils.utils_crystals.get_conventional_std_cell`.  \n</span>
<span class="sd">        `cell_type` = &#39;standard_no_symmetries&#39; creates a standard conventional cell without using symmetries.</span>
<span class="sd">        See :py:mod:`ai4materials.utils.utils_crystals.get_conventional_std_cell_no_sym`.  \n</span>
<span class="sd">        `cell_type` = &#39;primitive&#39; creates a standard primitive cell.</span>
<span class="sd">        See :py:mod:`ai4materials.utils.utils_crystals.get_primitive_std_cell`. \n</span>
<span class="sd">        `cell_type` = `None` does not creates any cell.</span>
<span class="sd">        It simply uses the unit cell as input for the supercell generation.</span>

<span class="sd">    Returns:</span>

<span class="sd">    `ase.Atoms`</span>
<span class="sd">        Atomic structure in the standard cell of the selected type.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">get_conventional_std_cell</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s1">&#39;standard_no_symmetries&#39;</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">get_conventional_std_cell_no_sym</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s1">&#39;primitive&#39;</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">get_primitive_std_cell</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized cell_type value.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">atoms</span></div>


<div class="viewcode-block" id="create_supercell"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.create_supercell">[docs]</a><span class="k">def</span> <span class="nf">create_supercell</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">create_replicas_by</span><span class="o">=</span><span class="s1">&#39;nb_atoms&#39;</span><span class="p">,</span> <span class="n">min_nb_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_nb_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">max_diff_nb_atoms</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_rotation_before</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_rotation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">optimal_supercell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_replicas</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a supercell specifying using a specified method.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms`</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    create_replicas_by: { &#39;nb_atoms&#39;, &#39;radius&#39;, &#39;user-defined&#39;}</span>
<span class="sd">        Method to calculate the replicas. \n</span>
<span class="sd">        `create_replicas_by` = &#39;nb_atoms&#39; creates a supercell &#39;naively&#39; as cubic as possible with the number of atoms</span>
<span class="sd">        as close as possible to `target_nb_atoms`. \n</span>
<span class="sd">        `create_replicas_by` = &#39;radius&#39; creates a supercell &#39;naively&#39; as cubic as possible with the number of atoms</span>
<span class="sd">        with the given radius. \n</span>
<span class="sd">        `create_replicas_by` = &#39;user-defined&#39; creates a supercell using the user-defined `target_replicas`</span>
<span class="sd">        integer of tuple to replicate the cell. See `target_replicas` below.</span>

<span class="sd">    min_nb_atoms: int</span>
<span class="sd">        Minimum number of atoms for the replicated structure.</span>
<span class="sd">        If the resulting structure has less atoms, an error will be raised.</span>

<span class="sd">    target_nb_atoms: int, optional</span>
<span class="sd">        Target number of atoms in the supercell created. The actual number of atoms might differ from it.</span>
<span class="sd">        See also `max_diff_nb_atoms` below.</span>
<span class="sd">        Used only if `create_replicas_by`=&#39;nb_atoms&#39;.</span>

<span class="sd">    max_diff_nb_atoms: int, optional</span>
<span class="sd">        Maximum (absolute) difference between the `target_nb_atoms` and the actual number of atoms present</span>
<span class="sd">        in the supercell. If the difference is larger, an error will be raised.</span>
<span class="sd">        Used only if `create_replicas_by`=&#39;nb_atoms&#39;.</span>

<span class="sd">    radius: float, optional</span>
<span class="sd">        Used only if `create_replicas_by`=&#39;radius&#39;.</span>

<span class="sd">    target_replicas: int or list/tuple of int, optional</span>
<span class="sd">        Number of replicas of the created supercell. \n</span>
<span class="sd">        `target_replicas` = 3 replicates the cell 3 times along the 3 directions \n</span>
<span class="sd">        `target_replicas` = (4,2,2) replicates the cell 4 times along the 1st direction, and 2 times along the other</span>
<span class="sd">        two directions.</span>
<span class="sd">        Used only if `create_replicas_by`=&#39;user-defined&#39;.</span>

<span class="sd">    random_rotation_before: bool, optional (default = `False`)</span>
<span class="sd">        Randomly rotate the structure sequentially along the x, y, and z axis by random angles BEFORE the</span>
<span class="sd">        supercell is created.</span>
<span class="sd">        Both the atomic positions and the cell are rotated so that periodic boundary conditions are respected.</span>

<span class="sd">    random_rotation: bool, optional (default = `False`)</span>
<span class="sd">        Randomly rotate the structure sequentially along the x, y, and z axis AFTER the supercell is created. \n</span>
<span class="sd">        Both the atomic positions and the cell are rotated so that periodic boundary conditions are respected.</span>

<span class="sd">    cell_type: { &#39;standard&#39;, &#39;standard_no_symmetries&#39;, &#39;primitive&#39;, None}</span>
<span class="sd">        Starting from the input cell, creates a standard cell according to same standards</span>
<span class="sd">        before the supercell generation. \n</span>
<span class="sd">        `cell_type` = &#39;standard&#39; creates a standard conventional cell.</span>
<span class="sd">        See :py:mod:`ai4materials.utils.utils_crystals.get_conventional_std_cell`.  \n</span>
<span class="sd">        `cell_type` = &#39;standard_no_symmetries&#39; creates a standard conventional cell without using symmetries.</span>
<span class="sd">        See :py:mod:`ai4materials.utils.utils_crystals.get_conventional_std_cell_no_sym`.  \n</span>
<span class="sd">        `cell_type` = &#39;primitive&#39; creates a standard primitive cell.</span>
<span class="sd">        See :py:mod:`ai4materials.utils.utils_crystals.get_primitive_std_cell`. \n</span>
<span class="sd">        `cell_type` = `None` does not creates any cell.</span>
<span class="sd">        It simply uses the unit cell as input for the supercell generation.</span>

<span class="sd">    optimal_supercell: bool, optional (default = `False`)</span>
<span class="sd">        Create a supercell with is &#39;optimally&#39; as close as possible to a simple cubic supercell. It can be slow. \n</span>
<span class="sd">        For more information, please visit:</span>
<span class="sd">        https://wiki.fysik.dtu.dk/ase/tutorials/defects/defects.html</span>
<span class="sd">        and the associated publication.</span>

<span class="sd">    Returns:</span>

<span class="sd">    `ase.Atoms`</span>
<span class="sd">        Atomic structure of the supercell.</span>

<span class="sd">    .. seealso:: Details on the supercell generation can be found in:</span>
<span class="sd">        :py:mod:`ai4materials.utils.utils_crystals.nb_of_replicas`.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the Python random instead of the numpy random is used because numpy does not get reseeded in multiprocessing</span>
    <span class="c1"># https://github.com/numpy/numpy/issues/9650</span>
    <span class="k">if</span> <span class="n">random_rotation_before</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">360.0</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">rotate_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;COU&#39;</span><span class="p">)</span>

        <span class="n">beta</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">360.0</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">rotate_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;COU&#39;</span><span class="p">)</span>

        <span class="n">gamma</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">360.0</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">rotate_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;COU&#39;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Structure rotated randomly by:&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">° around x-axis; </span><span class="si">{}</span><span class="s2">° around y-axis; </span><span class="si">{}</span><span class="s2">° around z-axis&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>

    <span class="n">atoms</span> <span class="o">=</span> <span class="n">standardize_cell</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">optimal_supercell</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using optimal supercell algorithm for replica determination. &quot;</span><span class="p">)</span>
        <span class="c1"># optimal supercell following https://wiki.fysik.dtu.dk/ase/tutorials/defects/defects.html</span>
        <span class="c1"># there is a scipy-based implementation (find_optimal_cell_shape) but it does not work</span>
        <span class="c1"># Wave is now a separate package (pip install wave), but ASE still try to import it from scipy</span>
        <span class="n">target_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">target_nb_atoms</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span>
        <span class="n">p_opt</span> <span class="o">=</span> <span class="n">find_optimal_cell_shape_pure_python</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="n">target_size</span><span class="p">,</span> <span class="n">target_shape</span><span class="o">=</span><span class="s1">&#39;sc&#39;</span><span class="p">,</span>
                                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dev_cubic</span> <span class="o">=</span> <span class="n">get_deviation_from_optimal_cell_shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p_opt</span><span class="p">,</span> <span class="n">atoms</span><span class="o">.</span><span class="n">cell</span><span class="p">))</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Optimal repetition matrix: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_opt</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Optimality measure (perfect cubic structure -&gt; 0.0): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dev_cubic</span><span class="p">))</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">make_supercell</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">p_opt</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">replicas</span> <span class="o">=</span> <span class="n">nb_of_replicas</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">create_replicas_by</span><span class="o">=</span><span class="n">create_replicas_by</span><span class="p">,</span> <span class="n">min_nb_atoms</span><span class="o">=</span><span class="n">min_nb_atoms</span><span class="p">,</span>
                                  <span class="n">target_nb_atoms</span><span class="o">=</span><span class="n">target_nb_atoms</span><span class="p">,</span> <span class="n">max_diff_nb_atoms</span><span class="o">=</span><span class="n">max_diff_nb_atoms</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
                                  <span class="n">target_replicas</span><span class="o">=</span><span class="n">target_replicas</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span> <span class="o">*</span> <span class="n">replicas</span>

    <span class="k">if</span> <span class="n">random_rotation</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">360.0</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">rotate_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;COU&#39;</span><span class="p">)</span>

        <span class="n">beta</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">360.0</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">rotate_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;COU&#39;</span><span class="p">)</span>

        <span class="n">gamma</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">360.0</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">rotate_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;COU&#39;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Structure rotated randomly by:&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">° around x-axis; </span><span class="si">{}</span><span class="s2">° around y-axis; </span><span class="si">{}</span><span class="s2">° around z-axis&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>

    <span class="c1"># wraps atoms back to the cell</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">wrap</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">atoms</span></div>


<div class="viewcode-block" id="rotate_atoms"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.rotate_atoms">[docs]</a><span class="k">def</span> <span class="nf">rotate_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">psi</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;COU&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Randomly rotate an ASE atoms structure via Euler angles in degree.</span>

<span class="sd">    This is simply a wrapper around:</span>
<span class="sd">    https://wiki.fysik.dtu.dk/ase/ase/atoms.html#ase.Atoms.euler_rotate</span>

<span class="sd">    For more info on Euler angles and for the convention followed by ASE:</span>
<span class="sd">    http://mathworld.wolfram.com/EulerAngles.html</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms`</span>
<span class="sd">        Atomic structure to be rotated</span>

<span class="sd">    center: sequence of length 3 or str</span>
<span class="sd">        The point to rotate about. A sequence of length 3 with the</span>
<span class="sd">        coordinates of the point, or:</span>
<span class="sd">        &#39;COM&#39; to select the center of mass \n</span>
<span class="sd">        &#39;COP&#39; to select center of positions \n</span>
<span class="sd">        &#39;COU&#39; to select center of cell.</span>

<span class="sd">    phi: float</span>
<span class="sd">        The 1st rotation angle around the z axis.</span>

<span class="sd">    theta: float</span>
<span class="sd">        Rotation around the x axis.</span>

<span class="sd">    psi: float</span>
<span class="sd">        2nd rotation around the z axis.</span>

<span class="sd">    Returns:</span>
<span class="sd">    `ase.Atoms` object</span>
<span class="sd">        The rotated atomic structure.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">atoms</span><span class="o">.</span><span class="n">euler_rotate</span><span class="p">(</span><span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">psi</span><span class="o">=</span><span class="n">psi</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">atoms</span></div>


<div class="viewcode-block" id="create_vacancies"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.create_vacancies">[docs]</a><span class="k">def</span> <span class="nf">create_vacancies</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">target_vacancy_ratio</span><span class="p">,</span> <span class="n">max_rel_error</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a supercell and then create vacancies in the constructed supercell.</span>

<span class="sd">    It is implicitly without replacement because the atoms are deleted</span>
<span class="sd">    at each iteration. This is why, for example, the implementation is different w.r.t.</span>
<span class="sd">    substitute atoms.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms`</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    target_vacancy_ratio: float</span>
<span class="sd">        Target percentage of vacancies. It must be a number between 0.0 (0.0 excluded)</span>
<span class="sd">        and 1.0 (all atoms removed). For example, 0.2 will lead to the removal of 20% of the atoms. \n</span>
<span class="sd">        The actual number of vacancies might differ from it, especially for</span>
<span class="sd">        small supercell and/or small percentage of vacancies. See also `max_rel_error` below.</span>

<span class="sd">    max_rel_error: float, optional (default = 0.25)</span>
<span class="sd">        Relative (absolute) difference between the `target_vacancy_ratio` and the actual percentage of atoms</span>
<span class="sd">        created in the supercell. If the difference is larger, a warning will be raised.</span>

<span class="sd">    Returns:</span>

<span class="sd">    `ase.Atoms`</span>
<span class="sd">        Supercell with vacancies.</span>

<span class="sd">    .. seealso:: The supercell is generated by:</span>
<span class="sd">        :py:mod:`ai4materials.utils.utils_crystals.create_supercell`.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">atoms</span> <span class="o">=</span> <span class="n">create_supercell</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">nb_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nb_atoms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="mf">0.</span> <span class="o">&lt;</span> <span class="n">target_vacancy_ratio</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="c1"># calculate the number of vancancies to make given the ratio</span>
            <span class="n">nb_vacancies</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nb_atoms</span> <span class="o">*</span> <span class="n">target_vacancy_ratio</span><span class="p">)</span>
            <span class="n">actual_vacancy_ratio</span> <span class="o">=</span> <span class="n">nb_vacancies</span> <span class="o">/</span> <span class="n">nb_atoms</span>

            <span class="c1"># randomly remove one atom from the supercell</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_vacancies</span><span class="p">):</span>
                <span class="n">idx_atom_to_delete</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">])</span>
                <span class="k">del</span> <span class="n">atoms</span><span class="p">[</span><span class="n">idx_atom_to_delete</span><span class="p">]</span>

            <span class="n">rel_error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target_vacancy_ratio</span> <span class="o">-</span> <span class="n">actual_vacancy_ratio</span><span class="p">)</span> <span class="o">/</span> <span class="n">target_vacancy_ratio</span>

            <span class="k">if</span> <span class="n">rel_error</span> <span class="o">&gt;</span> <span class="n">max_rel_error</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Difference between target and actual vacancy ratio &quot;</span>
                               <span class="s2">&quot;bigger than the threshold (</span><span class="si">{0}</span><span class="s2">%).</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;Target/actual vacancy ratio: </span><span class="si">{1}</span><span class="s2">%/</span><span class="si">{2}</span><span class="s2">%.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_rel_error</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">,</span>
                                                                                <span class="n">target_vacancy_ratio</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">,</span>
                                                                                <span class="n">actual_vacancy_ratio</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Number of atoms (before vacancies): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nb_atoms</span><span class="p">))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Number of vacancies: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nb_vacancies</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The vacancy ratio needs to be between 0 and 1. (0. excluded)&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Structure with no atoms. Continuing.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">atoms</span></div>


<div class="viewcode-block" id="substitute_atoms"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.substitute_atoms">[docs]</a><span class="k">def</span> <span class="nf">substitute_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">target_sub_ratio</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">max_n_sub_species</span><span class="o">=</span><span class="mi">94</span><span class="p">,</span> <span class="n">max_rel_error</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a supercell and then substitute in the constructed supercell.</span>

<span class="sd">    Atoms are substituted with other - randomly chosen - chemical species. The positions of the atoms in the</span>
<span class="sd">    lattice are not changed, only their chemical identity.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms`</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    target_sub_ratio: float</span>
<span class="sd">        Target percentage of atoms to be substituted. It must be a number between 0.0 (no vacancies created)</span>
<span class="sd">        and 1.0 (all atoms removed). For example, 0.2 will lead to the substitutions of 20% of the atoms. \n</span>
<span class="sd">        The actual number of substitutions might differ from it, especially for</span>
<span class="sd">        small supercell and/or small percentage of substitutions. See also `max_rel_error` below.</span>

<span class="sd">    max_n_sub_species: int, optional, (default = 94)</span>
<span class="sd">        The maximum number of species that can be used in the substitution procedure.</span>
<span class="sd">        For example: \n</span>
<span class="sd">        - `max_n_sub_species` = 1, will created a disordered binary. \n</span>
<span class="sd">        - `substitution_ratio` = 0.50 and `max_n_sub_species` = 1, will create a disordered binary with chemical species</span>
<span class="sd">        having the same stoichiometry. \n</span>
<span class="sd">        - `max_n_sub_species` = 2, a disordered ternary will be created.</span>

<span class="sd">    max_rel_error: float, optional (default = 0.25)</span>
<span class="sd">        Relative (absolute) difference between the `target_sub_ratio` and the actual percentage of atoms</span>
<span class="sd">        substituted in the supercell. If the difference is larger, a warning will be raised.</span>

<span class="sd">    Returns:</span>

<span class="sd">    `ase.Atoms`</span>
<span class="sd">        Supercell with randomly substituted atoms.</span>

<span class="sd">    .. seealso:: The supercell is generated by:</span>
<span class="sd">        :py:mod:`ai4materials.utils.utils_crystals.create_supercell`.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nb_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nb_atoms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">create_supercell</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="mf">0.</span> <span class="o">&lt;</span> <span class="n">target_sub_ratio</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="c1"># calculate the number of atoms to substitute to make given the ratio</span>
            <span class="n">nb_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">nb_subs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nb_atoms</span> <span class="o">*</span> <span class="n">target_sub_ratio</span><span class="p">)</span>
            <span class="n">actual_sub_ratio</span> <span class="o">=</span> <span class="n">nb_subs</span> <span class="o">/</span> <span class="n">nb_atoms</span>

            <span class="c1"># pick atomic numbers from 1 to 94</span>
            <span class="n">possible_atom_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">max_n_sub_species</span><span class="p">)</span>
            <span class="n">new_atomic_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">possible_atom_numbers</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nb_subs</span><span class="p">)</span>

            <span class="c1"># without replacement</span>
            <span class="n">idx_atom_to_change</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)),</span> <span class="n">size</span><span class="o">=</span><span class="n">nb_subs</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_subs</span><span class="p">):</span>
                <span class="n">atoms</span><span class="p">[</span><span class="n">idx_atom_to_change</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">new_atomic_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">rel_error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target_sub_ratio</span> <span class="o">-</span> <span class="n">actual_sub_ratio</span><span class="p">)</span> <span class="o">/</span> <span class="n">target_sub_ratio</span>

            <span class="k">if</span> <span class="n">rel_error</span> <span class="o">&gt;</span> <span class="n">max_rel_error</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Difference between target and actual substitution ratio &quot;</span>
                               <span class="s2">&quot;bigger than the threshold (</span><span class="si">{0}</span><span class="s2">%).</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="s2">&quot;Target/actual substitution ratio: </span><span class="si">{1}</span><span class="s2">%/</span><span class="si">{2}</span><span class="s2">%.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_rel_error</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">,</span>
                                                                                     <span class="n">target_sub_ratio</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">,</span>
                                                                                     <span class="n">actual_sub_ratio</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The substitution ratio needs to be comprised between 0.0 and 1.0.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Structure with no atoms. Continuing.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">atoms</span></div>


<div class="viewcode-block" id="random_displace_atoms"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.random_displace_atoms">[docs]</a><span class="k">def</span> <span class="nf">random_displace_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">noise_distribution</span><span class="p">,</span> <span class="n">displacement</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">displacement_scaled</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a supercell and then randomly displace atoms in the constructed supercell.</span>

<span class="sd">    Atoms are substituted with other - randomly chosen - chemical species. The positions of the atoms in the</span>
<span class="sd">    lattice are not changed, only their chemical identity.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms`</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    displacement: float, optional</span>
<span class="sd">        The parameter used in the noise distribution to generate random displacements. In Angstrom.</span>
<span class="sd">        Used only if `noise_distribution` = gaussian or `noise_distribution` = uniform.</span>

<span class="sd">    displacement_scaled: float, optional</span>
<span class="sd">        The parameter used in the noise distribution to generate random displacements. Pure number.</span>
<span class="sd">        For example, if `displacement_scaled` = 0.1, atoms will be displaced according to a Gaussian</span>
<span class="sd">        distribution with standard deviation equal to 10% of (approximately) the bond length.</span>
<span class="sd">        Used only if `noise_distribution` = gaussian_scaled.</span>

<span class="sd">    noise_distribution: { &#39;gaussian&#39;, &#39;uniform&#39;, &#39;gaussian_scaled&#39;, &#39;uniform_scaled&#39;}</span>
<span class="sd">        The type of noise distribution used to randomly displace atoms. \n</span>
<span class="sd">        - &#39;gaussian&#39;: displace atoms by values sampled from a Gaussian distribution with</span>
<span class="sd">        standard deviation equal to `displacement`. \n</span>
<span class="sd">        - &#39;uniform&#39;: displace atoms by values sampled from a distribution [-`displacement`, +`displacement`] \n</span>
<span class="sd">        - &#39;gaussian_scaled&#39;: displace atoms by a Gaussian distribution with standard deviation</span>
<span class="sd">        equal to `displacement` scaled by the nearest neighbors distance. \n</span>
<span class="sd">        - &#39;uniform_scaled&#39;: displace atoms by values sampled from a distribution [-`displacement`, +`displacement`]</span>
<span class="sd">        scaled by the nearest neighbors distance \n</span>

<span class="sd">    max_rel_error: float, optional (default = 0.25)</span>
<span class="sd">        Relative (absolute) difference between the `target_sub_ratio` and the actual percentage of atoms</span>
<span class="sd">        substituted in the supercell. If the difference is larger, a warning will be raised.</span>

<span class="sd">    Returns:</span>

<span class="sd">    `ase.Atoms`</span>
<span class="sd">        Supercell with randomly displaced atoms.</span>

<span class="sd">    .. seealso:: The supercell is generated by:</span>
<span class="sd">        :py:mod:`ai4materials.utils.utils_crystals.create_supercell`. \n</span>
<span class="sd">        If `noise_distribution` = gaussian_scaled, a quantity related to the average nearest neighbor distance</span>
<span class="sd">        is calculated. It is not exactly the average nearest neighbor distance because we use quantiles to be more</span>
<span class="sd">        robust with respect to defect. For more details, please go to</span>
<span class="sd">        :py:mod:`ai4materials.utils.utils_crystals.get_nn_distance`. \n</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nb_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nb_atoms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">create_supercell</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">noise_distribution</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">displacement</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Gaussian displacement with standard deviation </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">displacement</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Noise realization: min: </span><span class="si">{}</span><span class="s2">; max: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">noise</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="n">noise_distribution</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=-</span><span class="n">displacement</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">displacement</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">noise_distribution</span> <span class="o">==</span> <span class="s1">&#39;gaussian_scaled&#39;</span><span class="p">:</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">get_nn_distance</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">displacement_scaled</span> <span class="o">*</span> <span class="n">scale_factor</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">displacement</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">noise_distribution</span> <span class="o">==</span> <span class="s1">&#39;uniform_scaled&#39;</span><span class="p">:</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">get_nn_distance</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">displacement_scaled</span> <span class="o">*</span> <span class="n">scale_factor</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=-</span><span class="n">displacement</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">displacement</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Noise realization: min: </span><span class="si">{}</span><span class="s2">; max: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">noise</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The noise distribution chosen is not implemented.&quot;</span><span class="p">)</span>

        <span class="n">atoms</span><span class="o">.</span><span class="n">set_positions</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span> <span class="o">+</span> <span class="n">noise</span><span class="p">)</span>
        <span class="c1"># wrap atomic positions inside unit cell</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">wrap</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Structure with no atoms. Continuing.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">atoms</span></div>


<div class="viewcode-block" id="grouped"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.grouped">[docs]</a><span class="k">def</span> <span class="nf">grouped</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;s -&gt; (s0,s1,s2,...sn-1), (sn,sn+1,sn+2,...s2n-1), (s2n,s2n+1,s2n+2,...s3n-1), ...&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">izip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_min_distance"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.get_min_distance">[docs]</a><span class="k">def</span> <span class="nf">get_min_distance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">nb_splits</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the smallest distance between atoms in a given structure.</span>

<span class="sd">    Here we use the scipy implementation. Other implementations could also be used.</span>
<span class="sd">    For example: sklearn.metrics.pairwise.pairwise_distances or ase atoms.get_all_distances().</span>
<span class="sd">    Calculating all pairwise distances scales as N^2, where N is the number of atoms in the structure.</span>
<span class="sd">    This is clearly memory intensive, so we need to split the atoms in batches if we run out of memory.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms`</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    nb_splits: int, optional, (default = 100)</span>
<span class="sd">        Number of splits in which to divide the distance matrix in order to calculate the smallest</span>
<span class="sd">        distance between atoms in the atomic structure.</span>

<span class="sd">    Returns:</span>

<span class="sd">    float or None</span>
<span class="sd">        Smallest distance between the atoms in the structures. It returns `None` if the shortest distance cannot</span>
<span class="sd">        be calculated, for example because there are no atoms in the structure.</span>

<span class="sd">    .. seealso:: :py:mod:`ai4materials.utils.utils_crystals.get_nn_distance`.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nb_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">nb_atoms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span>
        <span class="n">num_elems</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">size_mb</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_elems</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">8.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">size_mb</span> <span class="o">&lt;</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">:</span>
            <span class="c1"># less than 1Gb</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
            <span class="n">dist_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="n">shortest_distance</span> <span class="o">=</span> <span class="n">dist_sort</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if the matrix is too big, splits the atoms</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Matrix dimension: </span><span class="si">{0:.1f}</span><span class="s2"> MB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size_mb</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Switching to low-memory requirement algorithm (slower).&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nb_splits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nb_splits</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size_mb</span> <span class="o">//</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">pos_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">nb_splits</span><span class="p">)</span>
            <span class="n">dist_sort</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pos_list_1</span><span class="p">,</span> <span class="n">pos_list_2</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">(</span><span class="n">pos_list</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">pos_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">pos_list_1</span><span class="p">,</span> <span class="n">pos_list_2</span><span class="p">))</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">pos_list</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
                <span class="n">dist_sort</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">dist</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">shortest_distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dist_sort</span><span class="p">)</span>

        <span class="k">del</span> <span class="n">dist</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">shortest_distance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Structure with no atoms. Continuing.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">shortest_distance</span></div>


<div class="viewcode-block" id="get_nn_distance"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.get_nn_distance">[docs]</a><span class="k">def</span> <span class="nf">get_nn_distance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="s1">&#39;quantile_nn&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
                    <span class="n">min_nb_nn</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_histogram</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">constrain_nn_distances</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nn_distances_cutoff</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate an &quot;averaged&quot; (actual average or quantile-based) nearest neighbors distance.</span>
<span class="sd">    This is a measure of the characteristic structural lengthscale of the system.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms`</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    distribution: { &#39;avg_nn&#39;, &#39;quantile_nn&#39;}</span>
<span class="sd">        Type of statistical function to be used in the lengthscale determination. \n</span>
<span class="sd">        - &#39;avg_nn&#39; simply averages the nearest neighbor distances.</span>
<span class="sd">        - &#39;quantile_nn&#39; used a quantile-based approach to be more robust w.r.t. outliers.</span>
<span class="sd">        These two choices are essentially equivalent for pristine structures, while the &#39;quantile_nn&#39;</span>
<span class="sd">        is more robust when defects are included.</span>

<span class="sd">    cutoff: float, optional, (default = 4.0)</span>
<span class="sd">        Cutoff (in Angstrom) for the radius within which atoms are considered neighbor.</span>
<span class="sd">        This neighbors will then be used to identify the nearest atom.</span>

<span class="sd">    min_nb_nn: int, optional, (default = 5)</span>
<span class="sd">        Minimum number of neighbors for a given atom to be considered.</span>
<span class="sd">        If an atom has less than `min_nb_nn` it will not be used in the determination of the system lengthscale.</span>

<span class="sd">    pbc: bool, optional, (default = True)</span>
<span class="sd">        `True` if periodic boundary conditions are used.</span>

<span class="sd">    plot_histogram: bool, optional, (default = True)</span>
<span class="sd">        If `True`, plot the histogram on the neighbor distances. It can be useful for debugging, especially</span>
<span class="sd">        for heavily defective structures, when the distribution changes substantially (w.r.t. the</span>
<span class="sd">        pristine crystal structure) due to disorder.</span>

<span class="sd">    bins: int, optional, (default = 100)</span>
<span class="sd">        Number of bins used in the histograms of the nearest neighbor distance function.</span>

<span class="sd">    constrain_nn_distances: bool, optional, (default = True)</span>
<span class="sd">        If `True`, nearest neighbor distances below the cutoff specified by the additional argument</span>
<span class="sd">        nn_distances_cutoff will be ignored.</span>
<span class="sd">        </span>
<span class="sd">    nn_distances_cutoff: float, optional, (default = 0.9)</span>
<span class="sd">        Cutoff for nearest neighbor distances.</span>

<span class="sd">    Returns:</span>

<span class="sd">    float or None</span>
<span class="sd">        Characteristic lengthscale of the system based on the nearest neighbors&#39; distance.</span>
<span class="sd">        Returns `None` if no characteristic lengthscale could be found.</span>

<span class="sd">    .. seealso:: :py:mod:`ai4materials.utils.utils_crystals.get_min_distance`.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">pbc</span><span class="p">:</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">set_pbc</span><span class="p">((</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

    <span class="n">nb_atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_number_of_atoms</span><span class="p">()</span>
    <span class="n">cutoffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nb_atoms</span><span class="p">)</span> <span class="o">*</span> <span class="n">cutoff</span>
    <span class="n">nl</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">(</span><span class="n">cutoffs</span><span class="p">,</span> <span class="n">skin</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">self_interaction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bothways</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">nl</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="n">nn_dist</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_atoms</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;List of neighbors of atom number </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
        <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">nl</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_nb_nn</span><span class="p">:</span>
            <span class="n">coord_central_atom</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="c1"># get positions of nearest neighbors within the cut-off</span>
            <span class="n">dist_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span><span class="p">):</span>
                <span class="c1"># center each neighbors wrt the central atoms</span>
                <span class="n">coord_neighbor</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_cell</span><span class="p">())</span>
                <span class="c1"># calculate distance between the central atoms and the neighbors</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coord_neighbor</span> <span class="o">-</span> <span class="n">coord_central_atom</span><span class="p">)</span>
                <span class="n">dist_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

            <span class="c1"># dist_list is the list of distances from the central_atoms</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">dist_list</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># get nearest neighbor distance</span>
                <span class="n">nn_dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">dist_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;List of neighbors is empty for some atom. Cutoff must be increased.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Atom </span><span class="si">{}</span><span class="s2"> has less than </span><span class="si">{}</span><span class="s2"> neighbours. Skipping.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">min_nb_nn</span><span class="p">))</span>


    <span class="k">if</span> <span class="n">constrain_nn_distances</span><span class="p">:</span>
         <span class="c1"># Select all nearest neighbor distances larger than nn_distances_cutoff</span>
         <span class="n">threshold_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nn_dist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nn_distances_cutoff</span> 
         <span class="n">nn_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">threshold_indices</span> <span class="p">,</span> <span class="n">nn_dist</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;avg_nn&#39;</span><span class="p">:</span>
        <span class="n">length_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nn_dist</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;quantile_nn&#39;</span><span class="p">:</span>
        <span class="c1"># get the center of the maximally populated bin</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">nn_dist</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># scale by r**2 because this is how the rdf is defined</span>
        <span class="c1"># the are of the spherical shells grows like r**2</span>
        <span class="n">hist_scaled</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx_shell</span><span class="p">,</span> <span class="n">hist_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hist</span><span class="p">):</span>
            <span class="n">hist_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">hist_i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">idx_shell</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="n">length_scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">hist_scaled</span><span class="p">)]</span> <span class="o">+</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">hist_scaled</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="k">if</span> <span class="n">plot_histogram</span><span class="p">:</span>
            <span class="c1"># this histogram is not scaled by r**2, it is only the count</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">nn_dist</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>  <span class="c1"># arguments are passed to np.histogram</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Histogram&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not recognized option for atoms_scaling. &quot;</span>
                         <span class="s2">&quot;Possible values are: &#39;min_nn&#39;, &#39;avg_nn&#39;, or &#39;quantile_nn&#39;.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">length_scale</span></div>


<div class="viewcode-block" id="scale_structure"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.scale_structure">[docs]</a><span class="k">def</span> <span class="nf">scale_structure</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">scaling_type</span><span class="p">,</span> <span class="n">atoms_scaling_cutoffs</span><span class="p">,</span> <span class="n">min_scale_factor</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_scale_factor</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span>
                    <span class="n">extrinsic_scale_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Scale an atomic structure by a given scalar determined based on nearest neighbors distance.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    atoms: `ase.Atoms`</span>
<span class="sd">        Atomic structure.</span>

<span class="sd">    scaling_type: { &#39;min_nn&#39;, &#39;avg_nn&#39;, &#39;quantile_nn&#39;}</span>
<span class="sd">        Type of scaling used in the atom structure scaling.</span>

<span class="sd">    atoms_scaling_cutoffs: list of floats</span>
<span class="sd">        List of cutoffs to be used in the determination of the lengthscale of the system in</span>
<span class="sd">        :py:mod:`ai4materials.utils.utils_crystals.get_nn_distance`. If the lengthscale calculation is not successful,</span>
<span class="sd">        the next cutoff (next elements in the list `atoms_scaling_cutoffs` is used.</span>

<span class="sd">    min_scale_factor: float, optional, (default = 0.5)</span>
<span class="sd">        If the calculated scale factor is below this value, the scaling will not be performed. In Angstrom.</span>
<span class="sd">        The next element in the `atoms_scaling_cutoffs` list will be used.</span>
<span class="sd">        This is used as a safety check because the scaling factor should correspond to physically motivated</span>
<span class="sd">        nearest neighbor distance in materials.</span>

<span class="sd">    max_scale_factor: float, optional, (default = 10.)</span>
<span class="sd">        If the calculated scale factor is above this value, the scaling will not be performed. In Angstrom.</span>
<span class="sd">        The next element in the `atoms_scaling_cutoffs` list will be used.</span>
<span class="sd">        This is used as a safety check because the scaling factor should correspond to physically motivated</span>
<span class="sd">        nearest neighbor distance in materials.</span>

<span class="sd">    Returns:</span>

<span class="sd">    `ase.Atoms`</span>
<span class="sd">        Scaled atomic structure.</span>

<span class="sd">    .. seealso:: :py:mod:`ai4materials.utils.utils_crystals.get_min_distance`, :py:mod:`ai4materials.utils.utils_crystals.get_nn_distance`.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">scale_factor</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">scaling_type</span> <span class="o">==</span> <span class="s1">&#39;min_nn&#39;</span><span class="p">:</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">get_min_distance</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">scaling_type</span> <span class="o">==</span> <span class="s1">&#39;avg_nn&#39;</span> <span class="ow">or</span> <span class="n">scaling_type</span> <span class="o">==</span> <span class="s1">&#39;quantile_nn&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx_cutoff</span><span class="p">,</span> <span class="n">cutoff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms_scaling_cutoffs</span><span class="p">):</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">get_nn_distance</span><span class="p">(</span><span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="n">scaling_type</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">scale_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">min_scale_factor</span> <span class="o">&lt;</span> <span class="n">scale_factor</span> <span class="o">&lt;</span> <span class="n">max_scale_factor</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Cut off of </span><span class="si">{0}</span><span class="s2"> was successful&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cutoff</span><span class="p">))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Scale factor: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;Scale factor with extrinsic scaling: </span><span class="si">{}</span><span class="s2"> Angstrom&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">scale_factor</span> <span class="o">*</span> <span class="n">extrinsic_scale_factor</span><span class="p">))</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Unable to obtain a physically meaningful scaling factor.&quot;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Scale factor: </span><span class="si">{}</span><span class="s2"> Angstrom&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;Scale factor with extrinsic scaling: </span><span class="si">{}</span><span class="s2"> Angstrom&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">scale_factor</span> <span class="o">*</span> <span class="n">extrinsic_scale_factor</span><span class="p">))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Increasing cutoff from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2"> Angstrom&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">atoms_scaling_cutoffs</span><span class="p">[</span><span class="n">idx_cutoff</span><span class="p">],</span> <span class="n">atoms_scaling_cutoffs</span><span class="p">[</span><span class="n">idx_cutoff</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Unable to obtain a scaling factor.&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Increasing cutoff from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2"> Angstrom&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">atoms_scaling_cutoffs</span><span class="p">[</span><span class="n">idx_cutoff</span><span class="p">],</span> <span class="n">atoms_scaling_cutoffs</span><span class="p">[</span><span class="n">idx_cutoff</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not recognized option for scaling_type. &quot;</span>
                         <span class="s2">&quot;Possible values are: &#39;min_nn&#39;, &#39;avg_nn&#39;, or &#39;quantile_nn&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># deep copy otherwise the original atoms structure will be scaled</span>
    <span class="c1"># and the spacegroup_number_actual will be wrong</span>
    <span class="n">atoms_tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">scale_factor</span> <span class="o">*</span> <span class="n">extrinsic_scale_factor</span>
    <span class="n">atoms_tmp</span><span class="o">.</span><span class="n">set_positions</span><span class="p">(</span><span class="n">atoms_tmp</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">scale_factor</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">atoms_tmp</span></div>


<div class="viewcode-block" id="get_spacegroup_old"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.get_spacegroup_old">[docs]</a><span class="k">def</span> <span class="nf">get_spacegroup_old</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">materials_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get spacegroup from a list of NOMAD structure.</span>

<span class="sd">    OBSOLETE. TO BE REMOVED.&quot;&quot;&quot;</span>

    <span class="n">energy_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">materials_class</span> <span class="o">==</span> <span class="s1">&#39;binaries&#39;</span><span class="p">:</span>
        <span class="c1"># Get chemical formula with two elements and total energy per binary.</span>
        <span class="n">chemical_formula</span> <span class="o">=</span> <span class="n">get_chemical_formula_binaries</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
        <span class="c1"># energy_total = 2 * structure.energy_total / len(structure)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chemical_formula</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">chemical_formula</span>
        <span class="c1"># energy_total = structure.energy_total</span>

    <span class="n">spacegroup_number</span> <span class="o">=</span> <span class="n">ase_get_spacegroup</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-03</span><span class="p">)</span><span class="o">.</span><span class="n">no</span>

    <span class="k">return</span> <span class="n">chemical_formula</span><span class="p">,</span> <span class="n">energy_total</span><span class="p">,</span> <span class="n">spacegroup_number</span></div>


<div class="viewcode-block" id="get_lattice_type"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.get_lattice_type">[docs]</a><span class="k">def</span> <span class="nf">get_lattice_type</span><span class="p">(</span><span class="n">structure</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get lattice_type from a list of NOMAD structure.&quot;&quot;&quot;</span>

    <span class="n">energy_total</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">chemical_formula</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">lattice_type</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">gIndexRun</span><span class="p">,</span> <span class="n">gIndexDesc</span><span class="p">),</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">energy_total</span><span class="p">[</span><span class="n">gIndexRun</span><span class="p">,</span> <span class="n">gIndexDesc</span><span class="p">]</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">energy_total</span><span class="p">[(</span><span class="n">gIndexRun</span><span class="p">,</span> <span class="n">gIndexDesc</span><span class="p">)]</span>
            <span class="n">chemical_formula</span><span class="p">[</span><span class="n">gIndexRun</span><span class="p">,</span> <span class="n">gIndexDesc</span><span class="p">]</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">chemical_formula</span><span class="p">[(</span><span class="n">gIndexRun</span><span class="p">,</span> <span class="n">gIndexDesc</span><span class="p">)]</span>

            <span class="n">lattice_type</span><span class="p">[</span><span class="n">gIndexRun</span><span class="p">,</span> <span class="n">gIndexDesc</span><span class="p">]</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">spacegroup_analyzer</span><span class="p">[</span>
                <span class="n">gIndexRun</span><span class="p">,</span> <span class="n">gIndexDesc</span><span class="p">]</span><span class="o">.</span><span class="n">get_lattice_type</span><span class="p">()</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">chemical_formula</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">energy_total</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">lattice_type</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_target_diff_dic"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.get_target_diff_dic">[docs]</a><span class="k">def</span> <span class="nf">get_target_diff_dic</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">sample_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spacegroup</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get a dictionary of dictionaries: samples -&gt; space group tuples -&gt; energy differences.</span>

<span class="sd">    Dropping all rows which do not correspond to the minimum energy per sample AND space group,</span>
<span class="sd">    then making a new data frame with space groups as columns. Finally constructing the dictionary</span>
<span class="sd">    of dictionaries.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    df: pandas data frame</span>
<span class="sd">        with columns=[samples_title, energies_title, SG_title]</span>

<span class="sd">    sample_key: string</span>
<span class="sd">        Needs to be column title of samples of input df</span>

<span class="sd">    energy: string</span>
<span class="sd">        Needs to be column title of energies of input df</span>

<span class="sd">    spacegroup: string</span>
<span class="sd">        Needs to be column title of space groups of input df</span>

<span class="sd">    Returns:</span>

<span class="sd">    dic_out : dictionary of dictionaries</span>
<span class="sd">        In the form:</span>
<span class="sd">        {</span>
<span class="sd">        sample_a: { (SG_1,SG_2):E_diff_a12, (SG_1,SG_3):E_diff_a13,...},</span>
<span class="sd">        sample_b: { (SG_1,SG_2):E_diff_b12, (SG_1,SG_3):E_diff_b13,... },</span>
<span class="sd">        ...</span>
<span class="sd">        }</span>
<span class="sd">        E_diff_a12 = energy_SG_1 - energy_SG_2   of sample a.</span>
<span class="sd">        Both (SG_1,SG_2) and (SG_2,SG_1) are considered.</span>
<span class="sd">        If SG_1 or SG_2 is NaN, energy difference to it is ignored.</span>

<span class="sd">    .. codeauthor:: Emre Ahmetcik &lt;ahmetcik@fhi-berlin.mpg.de&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># use only rows with minimum energies</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">sample_key</span><span class="p">,</span> <span class="n">spacegroup</span><span class="p">])[</span><span class="n">energy</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span> <span class="o">==</span> <span class="n">df</span><span class="p">[</span><span class="n">energy</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>

    <span class="c1"># make new table with the different supgroups as columns</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="p">[</span><span class="n">sample_key</span><span class="p">],</span> <span class="n">spacegroup</span><span class="p">)</span>

    <span class="c1"># make dictionary of dictionaries</span>
    <span class="n">SG_list</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span>
    <span class="n">Samples_list</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="n">dic_out</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">Samples_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Samples_list</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">not_nan_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">row</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">sample_dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">j_1</span><span class="p">,</span> <span class="n">j_2</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">not_nan_indices</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">SG_1</span><span class="p">,</span> <span class="n">SG_2</span> <span class="o">=</span> <span class="n">SG_list</span><span class="p">[</span><span class="n">j_1</span><span class="p">],</span> <span class="n">SG_list</span><span class="p">[</span><span class="n">j_2</span><span class="p">]</span>
            <span class="n">Energy_diff</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">j_1</span><span class="p">]</span> <span class="o">-</span> <span class="n">row</span><span class="p">[</span><span class="n">j_2</span><span class="p">]</span>
            <span class="n">sample_dic</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">SG_1</span><span class="p">,</span> <span class="n">SG_2</span><span class="p">):</span> <span class="n">Energy_diff</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">sample_dic</span><span class="p">:</span>
            <span class="n">dic_out</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_dic</span>
    <span class="k">return</span> <span class="n">dic_out</span></div>


<div class="viewcode-block" id="select_diff_from_dic"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.select_diff_from_dic">[docs]</a><span class="k">def</span> <span class="nf">select_diff_from_dic</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="n">spacegroup_tuples</span><span class="p">,</span> <span class="n">sample_key</span><span class="o">=</span><span class="s1">&#39;Mat&#39;</span><span class="p">,</span> <span class="n">drop_nan</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get data frame of selected spacegroup_tuples from dictionary of dictionaries.</span>

<span class="sd">        Creating a pandas data frame with columns of samples and selected space group tuples (energy differnces).</span>

<span class="sd">        Parameters:</span>

<span class="sd">        dic: dict {samples -&gt; space group tuples -&gt; energy differences.}</span>

<span class="sd">        spacegroup_tuples: tuple, list of tuples, tuples of tuples</span>
<span class="sd">            Each tuple has to contain two space groups numbers,</span>
<span class="sd">            to be looked up in the input dic.</span>

<span class="sd">        sample_key: string</span>
<span class="sd">            Will be the column title of the samples of the created data frame</span>

<span class="sd">        drop_nan: string, optional {&#39;rows&#39;, &#39;SG_tuples&#39;}</span>
<span class="sd">            Drops all rows or columns (SG_tuples) containing NaN.</span>

<span class="sd">    .. codeauthor:: Emre Ahmetcik &lt;ahmetcik@fhi-berlin.mpg.de&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spacegroup_tuples</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">spacegroup_tuples</span><span class="p">):</span>
        <span class="n">spacegroup_tuples</span> <span class="o">=</span> <span class="p">[</span><span class="n">spacegroup_tuples</span><span class="p">]</span>
    <span class="n">df_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">spacegroup_tuples</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">drop_nan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">drop_nan</span> <span class="o">==</span> <span class="s1">&#39;rows&#39;</span><span class="p">:</span>
            <span class="n">df_out</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">drop_nan</span> <span class="o">==</span> <span class="s1">&#39;SG_tuples&#39;</span><span class="p">:</span>
            <span class="n">df_out</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument &#39;drop_nan&#39; has to be &#39;None&#39;, &#39;rows&#39; or &#39;SG_tuples&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># check if df_out is empty</span>
    <span class="n">len_columns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_out</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="n">len_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_out</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">len_columns</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">len_rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">len_rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;rows&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;spacegroup_tuples&#39;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Dropping </span><span class="si">{0}</span><span class="s1"> with NaNs leads to empty data frame.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Hint: Select different spacegroup_tuples or set drop_nan=None&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">df_out</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df_out</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">sample_key</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df_out</span></div>


<div class="viewcode-block" id="convert_energy_substance"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.convert_energy_substance">[docs]</a><span class="k">def</span> <span class="nf">convert_energy_substance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">energy_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">length_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert energy to energy/substance and viceversa.</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ureg_path</span> <span class="o">=</span> <span class="n">get_data_filename</span><span class="p">(</span><span class="s1">&#39;utils/units.txt&#39;</span><span class="p">)</span>
    <span class="n">ureg</span> <span class="o">=</span> <span class="n">UnitRegistry</span><span class="p">(</span><span class="n">ureg_path</span><span class="p">)</span>
    <span class="n">unit_def</span> <span class="o">=</span> <span class="n">ureg</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
    <span class="n">energy_unit_def</span> <span class="o">=</span> <span class="n">ureg</span><span class="p">(</span><span class="n">energy_unit</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">unit_def</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">==</span> <span class="s1">&#39;[length] ** 2 * [mass] / [time] ** 2&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">energy_unit_def</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">==</span> <span class="s1">&#39;[length] ** 2 * [mass] / [substance] / [time] ** 2&#39;</span><span class="p">:</span>
            <span class="c1"># kj/mol and kcal/mol includes also [substance]</span>
            <span class="c1"># divide value by mol (multiply by Avogadro number)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">constants</span><span class="o">.</span><span class="n">Avogadro</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">constants</span><span class="o">.</span><span class="n">Avogadro</span>

            <span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span> <span class="o">+</span> <span class="s1">&#39;/mol&#39;</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">uc</span><span class="o">.</span><span class="n">convert_unit</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">target_unit</span><span class="o">=</span><span class="n">energy_unit</span><span class="p">)</span>  <span class="c1"># print feature, value, self.energy_unit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># already an actual energy</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">uc</span><span class="o">.</span><span class="n">convert_unit</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">target_unit</span><span class="o">=</span><span class="n">energy_unit</span><span class="p">)</span>  <span class="c1"># print feature, value, self.energy_unit</span>
    <span class="k">elif</span> <span class="n">unit_def</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">==</span> <span class="s1">&#39;[length]&#39;</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">uc</span><span class="o">.</span><span class="n">convert_unit</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">target_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">)</span>  <span class="c1"># print feature, value, self.length_unit</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># keep original units (or no units, e.g. Zvalence)</span>
        <span class="c1"># raise ValueError(&quot;Unit needs to be [energy], [energy]/[substance] or [length]&quot;)</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="format_e"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.format_e">[docs]</a><span class="k">def</span> <span class="nf">format_e</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform a float in a string to reduce the number of decimal places shown.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0:.3E}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="c1"># if it cannot convert, keep the original format</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">a</span></div>


<div class="viewcode-block" id="filter_ase_list_by_label"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.filter_ase_list_by_label">[docs]</a><span class="k">def</span> <span class="nf">filter_ase_list_by_label</span><span class="p">(</span><span class="n">ase_list</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">cell_type</span><span class="o">=</span><span class="s1">&#39;standard_no_symmetries&#39;</span><span class="p">,</span> <span class="n">main_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">filter_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">accepted_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">write_to_file</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">symprec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">all_symprec_consistent</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Filter the ase_list for the descriptor according to the spgroup value.</span>

<span class="sd">    Example:</span>
<span class="sd">    filter_by=[&#39;lattice_type&#39;, &#39;spacegroup_symbol&#39;],</span>
<span class="sd">    filter_by=[&#39;spacegroup_number&#39;],</span>

<span class="sd">    filter_by=[&#39;lattice_type&#39;],</span>
<span class="sd">    cell_type=cell_type,</span>
<span class="sd">    accepted_labels=accepted_label,</span>
<span class="sd">    accepted_labels=[[&#39;cubic&#39;], [&#39;Fd-3m&#39;, &#39;Fm-3m&#39;, &#39;Im-3m&#39;, &#39;Pm-3m&#39;]],</span>
<span class="sd">    [&#39;I-43m&#39;, &#39;P2_13&#39;, &#39;Pa3&#39;]</span>

<span class="sd">    .. codeauthor:: Angelo Ziletti &lt;angelo.ziletti@gmail.com&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">folder_to_write</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">main_folder</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">write_to_file</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">folder_to_write</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">folder_to_write</span><span class="p">)</span>

    <span class="n">labels_filtered</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">filtered_ase_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># create empty list for each filter_by value to append values later and check which unique values are selected</span>
    <span class="k">for</span> <span class="n">filter_</span> <span class="ow">in</span> <span class="n">filter_by</span><span class="p">:</span>
        <span class="n">labels_filtered</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">filter_</span><span class="p">):</span> <span class="p">[]})</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ase_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ase_list</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reading: file </span><span class="si">{0}</span><span class="s2">/</span><span class="si">{1}</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;to filter the atomic structure list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ase_list</span><span class="p">)))</span>

        <span class="n">atoms</span> <span class="o">=</span> <span class="n">standardize_cell</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">)</span>

        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;spacegroup_nb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;crystal_system&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;lattice_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">space_group_analyzer</span> <span class="o">=</span> <span class="n">get_spacegroup_analyzer</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">space_group_analyzer</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;spacegroup_nb&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get_space_group_number</span><span class="p">()</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;crystal_system&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get_crystal_system</span><span class="p">()</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;lattice_type&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get_lattice_type</span><span class="p">()</span>
            <span class="c1"># labels.update({&#39;json_file&#39;: json_file})</span>

        <span class="k">if</span> <span class="n">filter_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_count</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">id_filter</span><span class="p">,</span> <span class="n">filter_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filter_by</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">all_symprec_consistent</span><span class="p">:</span>
                    <span class="c1"># consider only systems with a consistent classification</span>
                    <span class="n">filter_values</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">filter_</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">filter_values</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">filter_values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">filter_values</span><span class="p">):</span>
                        <span class="n">filter_value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">filter_values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="c1"># look if the property which we want to filter by</span>
                        <span class="c1"># is included in the atoms.info dictionary with the</span>
                        <span class="c1"># correct value</span>
                        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">filter_value</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accepted_labels</span><span class="p">[</span><span class="n">id_filter</span><span class="p">]:</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">labels_filtered</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">filter_</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filter_value</span><span class="p">)</span>
                            <span class="n">filter_count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Values of </span><span class="si">{}</span><span class="s2"> are not unique w.r.t. the symmetry precision used.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filter_</span><span class="p">))</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Values are </span><span class="si">{}</span><span class="s2"> for precision </span><span class="si">{}</span><span class="s2">, respectively.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filter_values</span><span class="p">,</span> <span class="n">symprec</span><span class="p">))</span>

            <span class="c1"># append to the filtered json only if everything is matching</span>
            <span class="k">if</span> <span class="n">filter_count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">filter_by</span><span class="p">):</span>
                <span class="n">filtered_ase_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">filter_</span> <span class="ow">in</span> <span class="n">filter_by</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;List of unique values for filter &#39;</span><span class="si">{0}</span><span class="s2">&#39;: &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">filter_</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">labels_filtered</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">filter_</span><span class="p">)]))))</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;List of &#39;accepted labels&#39;: &quot;</span>
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">accepted_labels</span><span class="p">))</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Length of the whole ASE structure list: &quot;</span>
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ase_list</span><span class="p">)))</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Length of the filtered ASE structure list: &quot;</span>
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_ase_list</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">write_to_file</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Writing filtered ase list to file in folder: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">folder_to_write</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filtered_ase_list</span><span class="p">):</span>
            <span class="n">ase_db_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_to_write</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))))</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ase_db_filename</span> <span class="o">+</span> <span class="s1">&#39;.json&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;json&#39;</span><span class="p">)</span>

    <span class="c1"># write also a recap file</span>
    <span class="c1">#     results = {&quot;filtered_json_list&quot;: filtered_json_list, &quot;spacegroup_list&quot;: spacegroup_list,</span>
    <span class="c1">#                &quot;unique_spacegroup_list&quot;: list(set(spacegroup_list)), &quot;accepted_labels&quot;: accepted_labels,</span>
    <span class="c1">#                &quot;values_filter&quot;: labels_filtered, &quot;filter_by&quot;: filter_by, &quot;symprec&quot;: symprec,</span>
    <span class="c1">#                &quot;angle_tolerance&quot;: angle_tolerance}</span>
    <span class="c1">#</span>
    <span class="c1">#     with open(filtered_file, &quot;w&quot;) as f:</span>
    <span class="c1">#         f.write(&quot;&quot;&quot;</span>
    <span class="c1"># {</span>
    <span class="c1">#       &quot;data&quot;:[&quot;&quot;&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#         json.dump(results, f, indent=2)</span>
    <span class="c1">#</span>
    <span class="c1">#         f.write(&quot;&quot;&quot;</span>
    <span class="c1"># ] }&quot;&quot;&quot;)</span>
    <span class="c1">#         f.flush()</span>

    <span class="k">return</span> <span class="n">filtered_ase_list</span></div>


<div class="viewcode-block" id="rot_mat_x"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.rot_mat_x">[docs]</a><span class="k">def</span> <span class="nf">rot_mat_x</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the rotation matrix for a rotation around the x axis&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)),</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">))],</span>
                     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">))]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></div>


<div class="viewcode-block" id="rot_mat_y"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.rot_mat_y">[docs]</a><span class="k">def</span> <span class="nf">rot_mat_y</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the rotation matrix for a rotation around the y axis&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">))],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                     <span class="p">[</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">))]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></div>


<div class="viewcode-block" id="rot_mat_z"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.rot_mat_z">[docs]</a><span class="k">def</span> <span class="nf">rot_mat_z</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the rotation matrix for a rotation around the z axis&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)),</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)),</span> <span class="mi">0</span><span class="p">],</span>
                     <span class="p">[</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)),</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></div>


<div class="viewcode-block" id="interpolate_parameters"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.interpolate_parameters">[docs]</a><span class="k">def</span> <span class="nf">interpolate_parameters</span><span class="p">(</span><span class="n">initial_params</span><span class="p">,</span> <span class="n">final_params</span><span class="p">,</span> <span class="n">nb_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">include_final</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a list of initial and final parameters, linearly interpolated between them.&quot;&quot;&quot;</span>
    <span class="n">step_params</span> <span class="o">=</span> <span class="p">(</span><span class="n">final_params</span> <span class="o">-</span> <span class="n">initial_params</span><span class="p">)</span> <span class="o">/</span> <span class="n">nb_steps</span>

    <span class="k">if</span> <span class="n">include_final</span><span class="p">:</span>
        <span class="n">nb_param_sets</span> <span class="o">=</span> <span class="n">nb_steps</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nb_param_sets</span> <span class="o">=</span> <span class="n">nb_steps</span>

    <span class="n">params_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_param_sets</span><span class="p">):</span>
        <span class="n">curr_params</span> <span class="o">=</span> <span class="n">initial_params</span> <span class="o">+</span> <span class="n">step_params</span> <span class="o">*</span> <span class="n">idx</span>
        <span class="n">params_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">params_list</span></div>


<div class="viewcode-block" id="get_boxes_from_xyz"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.get_boxes_from_xyz">[docs]</a><span class="k">def</span> <span class="nf">get_boxes_from_xyz</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">sliding_volume</span><span class="p">,</span> <span class="n">stride_size</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">element_agnostic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">give_atom_density</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_atom_density</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">padding_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine boxes for strided pattern analysis.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    </span>
<span class="sd">    filename: string </span>
<span class="sd">    Name of xyz input file specifying the polycrystal.</span>
<span class="sd">    </span>
<span class="sd">    sliding_volume: 1D list</span>
<span class="sd">    3 floats specifying sliding volume.</span>
<span class="sd">    </span>
<span class="sd">    stride_size: 1D list</span>
<span class="sd">    3 floats specifying stride size in x,y and z direction.</span>
<span class="sd">    </span>
<span class="sd">    adapt: bool,optional (default=True)</span>
<span class="sd">    If true, adapt minimum and possibly stride size such that distortions in heatmaps are reduced.</span>
<span class="sd">    </span>
<span class="sd">    element_agnostic: bool, optional (default=False)</span>
<span class="sd">    If true, consider all atoms to be of the same chemical species and return boxes containing only &#39;Fe&#39; atoms.</span>
<span class="sd">    </span>
<span class="sd">    give_atom_density: bool, optional (default=False)</span>
<span class="sd">    If true, atom density is returned.</span>
<span class="sd">    </span>
<span class="sd">    plot_atom_density: bool, optional (default=False)</span>
<span class="sd">    If true, density of number of atoms is plotted as 2D heatmap for each z.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">    Depending on the parameter give_atom_density, return will be 3D list of xyz boxes plus 3D list of atomic number</span>
<span class="sd">    density or only the 3D list of xyz boxes.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">padding_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">padding_ratio</span><span class="p">,</span> <span class="n">sliding_volume</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>

    <span class="c1"># Get x,y,z coordinate vectors and coordinate range</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">coordinate_vector_and_element_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 2D list with each element = [coordinate vector(1D list),&#39;element name&#39;]</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># skip first two lines since they do not contain coordinates,</span>
    <span class="c1"># only number of total atoms and a comment line</span>
    
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="c1"># Save all x,y and z coordinates in separate arrays</span>
        <span class="c1"># to determine min,max and range later on</span>
        <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">3</span><span class="p">]))</span>
        <span class="c1"># Define list of coordinate vectors used for determining those atoms</span>
        <span class="c1"># within a certain sliding box</span>
        <span class="n">coordinate_vector</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">3</span><span class="p">])]</span>
        <span class="n">coordinate_vector_and_element_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">coordinate_vector</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">z_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">z_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">x_range</span> <span class="o">=</span> <span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span>
    <span class="n">y_range</span> <span class="o">=</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span>
    <span class="n">z_range</span> <span class="o">=</span> <span class="n">z_max</span><span class="o">-</span><span class="n">z_min</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;x range: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x_range</span><span class="p">))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;y range: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">y_range</span><span class="p">))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;z range: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z_range</span><span class="p">))</span>
    
    <span class="c1"># Size of sliding window</span>
    <span class="n">x_sliding_volume_edge_length</span> <span class="o">=</span> <span class="n">sliding_volume</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y_sliding_volume_edge_length</span> <span class="o">=</span> <span class="n">sliding_volume</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">z_sliding_volume_edge_length</span> <span class="o">=</span> <span class="n">sliding_volume</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="c1"># Step size for sliding window</span>
    <span class="n">step_size_x</span> <span class="o">=</span> <span class="n">stride_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">step_size_y</span> <span class="o">=</span> <span class="n">stride_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">step_size_z</span> <span class="o">=</span> <span class="n">stride_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Check if step size exceeds coordinate range - if true, set range equal to step</span>
    <span class="c1"># size in that direction such that number of strides, which is computed</span>
    <span class="c1"># via range/step size, is equal to one and at least one step is made.</span>
    <span class="c1"># if step_size_x &gt; x_range:</span>
    <span class="c1">#     logger.warning(&#39;x stride size exceeds x-coordinate range&#39;)</span>
    <span class="c1">#     x_range = step_size_x</span>
    <span class="c1">#     # this ensures int(x_range/step_size_x)=1 to be nonempty such that make one step in x direction</span>
    <span class="c1"># if step_size_y &gt; y_range:</span>
    <span class="c1">#     logger.warning(&#39;y stride size exceeds y-coordinate range&#39;)</span>
    <span class="c1">#     y_range = step_size_y</span>
    <span class="c1"># if step_size_z &gt; z_range:</span>
    <span class="c1">#     logger.warning(&#39;z stride size exceeds z-coordinate range&#39;)</span>
    <span class="c1">#     z_range = step_size_z</span>

    <span class="c1"># In the following, shift minimum value such that last sliding box does not overlap too</span>
    <span class="c1"># much into empty space and distortion in heatmaps is reduced.</span>

    <span class="n">min_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">z_min</span><span class="p">])</span>
    <span class="n">max_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">z_max</span><span class="p">])</span>

    <span class="n">number_of_strides_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x_range</span><span class="o">/</span><span class="n">step_size_x</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">y_range</span><span class="o">/</span><span class="n">step_size_y</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
         <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">z_range</span><span class="o">/</span><span class="n">step_size_z</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">stride_size_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">step_size_x</span><span class="p">,</span> <span class="n">step_size_y</span><span class="p">,</span> <span class="n">step_size_z</span><span class="p">])</span>
    <span class="n">sliding_volume_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">x_sliding_volume_edge_length</span><span class="p">,</span> <span class="n">y_sliding_volume_edge_length</span><span class="p">,</span> <span class="n">z_sliding_volume_edge_length</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">adapt</span><span class="p">:</span>
        <span class="c1"># take number_of_strides_vector-1 because first step at minimum taken into account</span>
        <span class="n">overhang</span> <span class="o">=</span> <span class="n">min_vector</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">number_of_strides_vector</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                          <span class="n">stride_size_vector</span><span class="p">)</span><span class="o">+</span><span class="n">sliding_volume_vector</span><span class="o">-</span><span class="n">max_vector</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Minimum: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_vector</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Maximum: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_vector</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Number of strides: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">number_of_strides_vector</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Stride size: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stride_size_vector</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sliding volume: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sliding_volume_vector</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Resulting overhang: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">overhang</span><span class="p">))</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>  <span class="c1"># go through x,y,z coordinates of overhang vector</span>
            
            <span class="c1"># If overhang is negative, i.e. sliding box is so small that in the last step structure is potentially lost,</span>
            <span class="c1"># increase the number of strides automatically until overhang becomes positive (or zero)</span>
            <span class="k">if</span> <span class="n">overhang</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">overhang</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;In direction x_</span><span class="si">{}</span><span class="s2">: overhang&lt;0&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
                    <span class="n">number_of_strides_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># need to recompute overhang</span>
                    <span class="n">overhang</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">number_of_strides_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">stride_size_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
                        <span class="n">sliding_volume_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;In direction x_</span><span class="si">{}</span><span class="s2">: residual overhang = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">overhang</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
            
            <span class="k">if</span> <span class="n">overhang</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;In direction x_</span><span class="si">{}</span><span class="s2">: overhang=0&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
    
            <span class="c1"># At this point the overhang is either zero or positive.</span>
            <span class="c1"># In the latter case, half of the overhang is subtracted from the minimum vector such that</span>
            <span class="c1"># boundary effects in the heatmaps are reduced</span>
            <span class="k">if</span> <span class="n">overhang</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;In direction x_</span><span class="si">{}</span><span class="s2">: overhang&gt;0&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
                <span class="n">min_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">overhang</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;New min: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_vector</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;New number of strides: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">number_of_strides_vector</span><span class="p">))</span>

    <span class="n">x_min</span> <span class="o">=</span> <span class="n">min_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="n">min_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">z_min</span> <span class="o">=</span> <span class="n">min_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Now determine boxes</span>
    
    <span class="c1"># start vector</span>
    <span class="n">start</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_min</span><span class="o">+</span><span class="n">x_sliding_volume_edge_length</span><span class="p">,</span> <span class="n">y_min</span><span class="o">+</span><span class="n">y_sliding_volume_edge_length</span><span class="p">,</span> <span class="n">z_min</span><span class="o">+</span><span class="n">z_sliding_volume_edge_length</span><span class="p">]</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Start vector: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>

    <span class="n">list_of_xyz_boxes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">number_of_atoms_xyz</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># if z_range=step_size_z (see if branches above) then range(...)=range(1)=[0]!</span>
    <span class="c1"># So z=str(k*step_sze_z) gives correct z position, namely z=0 and sliding box is oriented to the positive side</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_strides_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>

        <span class="n">list_of_xy_boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">number_of_atoms_xy</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_strides_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            
            <span class="n">list_of_x_boxes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">number_of_atoms_x</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_strides_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                
                <span class="c1"># Determine atoms within sliding box</span>
                <span class="n">positionvectors_within_sliding_volume</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">element_names_within_sliding_volume</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

                <span class="k">for</span> <span class="n">vector</span><span class="p">,</span> <span class="n">element_name</span> <span class="ow">in</span> <span class="n">coordinate_vector_and_element_list</span><span class="p">:</span>
                    <span class="n">condition</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> \
                                <span class="ow">and</span> <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">x_sliding_volume_edge_length</span><span class="p">)</span> \
                                <span class="ow">and</span> <span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">y_sliding_volume_edge_length</span><span class="p">)</span> \
                                <span class="ow">and</span> <span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">z_sliding_volume_edge_length</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
                        <span class="n">positionvectors_within_sliding_volume</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
                        <span class="n">element_names_within_sliding_volume</span> <span class="o">+=</span> <span class="n">element_name</span>
                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positionvectors_within_sliding_volume</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">number_of_atoms_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    
                    <span class="n">element_name</span> <span class="o">=</span> <span class="n">element_names_within_sliding_volume</span>  <span class="c1"># should be &#39;&#39;</span>
                    <span class="c1"># create ase Atoms object Atoms(symbols=&#39;&#39;,pbc=False)</span>
                    <span class="n">atoms_within_sliding_volume</span> <span class="o">=</span> <span class="n">ase</span><span class="o">.</span><span class="n">Atoms</span><span class="p">(</span><span class="n">element_name</span><span class="p">)</span>
                    <span class="c1"># Optional: assign label</span>
                    <span class="c1"># atoms_within_sliding_volume.info[&#39;label&#39;]=&#39;box_label_&#39;+str(i)+str(j)+str(k)</span>
                    <span class="n">list_of_x_boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atoms_within_sliding_volume</span><span class="p">)</span>
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">number_of_atoms_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">positionvectors_within_sliding_volume</span><span class="p">))</span>
                    
                    <span class="k">if</span> <span class="n">element_agnostic</span><span class="p">:</span>
                        <span class="n">element_name</span> <span class="o">=</span> <span class="s1">&#39;Fe&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">positionvectors_within_sliding_volume</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">element_name</span> <span class="o">=</span> <span class="n">element_names_within_sliding_volume</span>
                    <span class="n">atoms_within_sliding_volume</span> <span class="o">=</span> <span class="n">ase</span><span class="o">.</span><span class="n">Atoms</span><span class="p">(</span><span class="n">element_name</span><span class="p">,</span> <span class="n">positionvectors_within_sliding_volume</span><span class="p">)</span>
                    <span class="c1"># Optional: assign label</span>
                    <span class="c1"># atoms_within_sliding_volume.info[&#39;label&#39;]=&#39;box_label_&#39;+str(i)+str(j)+str(k)</span>
                    <span class="n">list_of_x_boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atoms_within_sliding_volume</span><span class="p">)</span>
                
                <span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">step_size_x</span>

            <span class="n">number_of_atoms_xy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">number_of_atoms_x</span><span class="p">)</span>
            <span class="n">list_of_xy_boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_of_x_boxes</span><span class="p">)</span>
            <span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_min</span><span class="o">+</span><span class="n">x_sliding_volume_edge_length</span>  <span class="c1"># Reset x_value after most inner for loop finished</span>
            <span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">step_size_y</span>  <span class="c1"># next y</span>
        
        <span class="n">number_of_atoms_xyz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">number_of_atoms_xy</span><span class="p">)</span>
        <span class="n">list_of_xyz_boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_of_xy_boxes</span><span class="p">)</span>
        <span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_min</span><span class="o">+</span><span class="n">y_sliding_volume_edge_length</span>  <span class="c1"># Reset y_value for next z coordinate</span>
        <span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">step_size_z</span>
        
    <span class="k">if</span> <span class="n">give_atom_density</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">plot_atom_density</span><span class="p">:</span>
            
            <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">xy_density</span> <span class="ow">in</span> <span class="n">number_of_atoms_xyz</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x $[\mathrm{\AA}]$&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y $[\mathrm{\AA}]$&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Atom density for z=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">xy_density</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span>
                           <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xy_density</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">*</span><span class="n">stride_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xy_density</span><span class="p">))</span><span class="o">*</span><span class="n">stride_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_Atom_density_for_z=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                
                <span class="n">z</span> <span class="o">+=</span> <span class="n">stride_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">list_of_xyz_boxes</span><span class="p">,</span> <span class="n">number_of_atoms_xyz</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">list_of_xyz_boxes</span></div>


<div class="viewcode-block" id="rename_material"><a class="viewcode-back" href="../../../ai4materials.utils.utils_crystals.html#ai4materials.utils.utils_crystals.rename_material">[docs]</a><span class="k">def</span> <span class="nf">rename_material</span><span class="p">(</span><span class="n">chem_f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Patch to rename certain binaries with the more electronegative element first.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chem_f</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;FLi&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;LiF&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;ClLi&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;LiCl&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;BrLi&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;LiBr&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;ILi&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;LiI&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;AsB&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;BAs&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;FNa&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;NaF&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;ClNa&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;NaCl&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;BrNa&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;NaBr&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;INa&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;NaI&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;CSi&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;SiC&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;FK&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;KF&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;ClK&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;KCl&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;BrK&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;KBr&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;IK&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;KI&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;ClCu&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;CuCl&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;BrCu&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;CuBr&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;OZn&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;ZnO&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;SZn&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;ZnS&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;SeZn&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;ZnSe&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;TeZn&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;ZnTe&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;AsGe&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;GeAs&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;FRb&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;RbF&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;ClRb&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;RbCl&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;BrRb&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;RbBr&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;IRb&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;RbI&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;OSr&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;SrO&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;SSr&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;SrS&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;SeSr&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;SrSe&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;AsIn&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;InAs&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;ClCs&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;CsCl&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;BrCs&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;CsBr&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;SiSn&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;SnSi&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;CGe&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;GeC&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;GeSn&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;SnGe&#39;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="s1">&#39;CSn&#39;</span><span class="p">:</span>
            <span class="n">chem_f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;SnC&#39;</span>

    <span class="k">return</span> <span class="n">chem_f</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2018, Angelo Ziletti.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>